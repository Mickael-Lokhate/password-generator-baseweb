"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/baseui/esm/slider/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/baseui/esm/slider/constants.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"STATE_CHANGE_TYPE\": function() { return /* binding */ STATE_CHANGE_TYPE; }\n/* harmony export */ });\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nvar STATE_CHANGE_TYPE = Object.freeze({\n  change: 'change',\n  finalChange: 'finalChange'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvY29uc3RhbnRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2V1aS9lc20vc2xpZGVyL2NvbnN0YW50cy5qcz85YTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cblRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cbmV4cG9ydCB2YXIgU1RBVEVfQ0hBTkdFX1RZUEUgPSBPYmplY3QuZnJlZXplKHtcbiAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgZmluYWxDaGFuZ2U6ICdmaW5hbENoYW5nZSdcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/constants.js\n");

/***/ }),

/***/ "./node_modules/baseui/esm/slider/index.js":
/*!*************************************************!*\
  !*** ./node_modules/baseui/esm/slider/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Slider\": function() { return /* reexport safe */ _slider_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   \"StatefulContainer\": function() { return /* reexport safe */ _stateful_slider_container_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   \"StatefulSlider\": function() { return /* reexport safe */ _stateful_slider_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   \"StyledInnerThumb\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.InnerThumb; },\n/* harmony export */   \"StyledInnerTrack\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.InnerTrack; },\n/* harmony export */   \"StyledMark\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.Mark; },\n/* harmony export */   \"StyledRoot\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.Root; },\n/* harmony export */   \"StyledThumb\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.Thumb; },\n/* harmony export */   \"StyledThumbValue\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.ThumbValue; },\n/* harmony export */   \"StyledTick\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.Tick; },\n/* harmony export */   \"StyledTickBar\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.TickBar; },\n/* harmony export */   \"StyledTrack\": function() { return /* reexport safe */ _styled_components_js__WEBPACK_IMPORTED_MODULE_3__.Track; }\n/* harmony export */ });\n/* harmony import */ var _slider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slider.js */ \"./node_modules/baseui/esm/slider/slider.js\");\n/* harmony import */ var _stateful_slider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stateful-slider.js */ \"./node_modules/baseui/esm/slider/stateful-slider.js\");\n/* harmony import */ var _stateful_slider_container_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stateful-slider-container.js */ \"./node_modules/baseui/esm/slider/stateful-slider-container.js\");\n/* harmony import */ var _styled_components_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./styled-components.js */ \"./node_modules/baseui/esm/slider/styled-components.js\");\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\n // Styled elements\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2dEO0FBQ2lCO0FBQ2EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvaW5kZXguanM/NmMyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG5UaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbkxJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNsaWRlciB9IGZyb20gJy4vc2xpZGVyLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3RhdGVmdWxTbGlkZXIgfSBmcm9tICcuL3N0YXRlZnVsLXNsaWRlci5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0YXRlZnVsQ29udGFpbmVyIH0gZnJvbSAnLi9zdGF0ZWZ1bC1zbGlkZXItY29udGFpbmVyLmpzJzsgLy8gU3R5bGVkIGVsZW1lbnRzXG5cbmV4cG9ydCB7IFJvb3QgYXMgU3R5bGVkUm9vdCwgVHJhY2sgYXMgU3R5bGVkVHJhY2ssIElubmVyVHJhY2sgYXMgU3R5bGVkSW5uZXJUcmFjaywgVGh1bWIgYXMgU3R5bGVkVGh1bWIsIElubmVyVGh1bWIgYXMgU3R5bGVkSW5uZXJUaHVtYiwgVGljayBhcyBTdHlsZWRUaWNrLCBUaWNrQmFyIGFzIFN0eWxlZFRpY2tCYXIsIFRodW1iVmFsdWUgYXMgU3R5bGVkVGh1bWJWYWx1ZSwgTWFyayBhcyBTdHlsZWRNYXJrIH0gZnJvbSAnLi9zdHlsZWQtY29tcG9uZW50cy5qcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/index.js\n");

/***/ }),

/***/ "./node_modules/baseui/esm/slider/slider.js":
/*!**************************************************!*\
  !*** ./node_modules/baseui/esm/slider/slider.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-range */ \"./node_modules/baseui/node_modules/react-range/lib/index.js\");\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_range__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_focusVisible_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/focusVisible.js */ \"./node_modules/baseui/esm/utils/focusVisible.js\");\n/* harmony import */ var _styled_components_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./styled-components.js */ \"./node_modules/baseui/esm/slider/styled-components.js\");\n/* harmony import */ var _helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/overrides.js */ \"./node_modules/baseui/esm/helpers/overrides.js\");\n/* harmony import */ var _styles_theme_provider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/theme-provider.js */ \"./node_modules/baseui/esm/styles/theme-provider.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\n\n\n\n // value.length should not be bigger than two\n// because our design doesn't support more than\n// two thumbs\n\nvar limitValue = function limitValue(value) {\n  if (value.length > 2 || value.length === 0) {\n    throw new Error('the value prop represents positions of thumbs, so its length can be only one or two');\n  }\n\n  return value;\n};\n\nfunction Slider(_ref) {\n  var _ref$overrides = _ref.overrides,\n      overrides = _ref$overrides === void 0 ? {} : _ref$overrides,\n      _ref$disabled = _ref.disabled,\n      disabled = _ref$disabled === void 0 ? false : _ref$disabled,\n      _ref$marks = _ref.marks,\n      marks = _ref$marks === void 0 ? false : _ref$marks,\n      _ref$onChange = _ref.onChange,\n      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,\n      _ref$onFinalChange = _ref.onFinalChange,\n      _onFinalChange = _ref$onFinalChange === void 0 ? function () {} : _ref$onFinalChange,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 100 : _ref$max,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 1 : _ref$step,\n      _ref$persistentThumb = _ref.persistentThumb,\n      persistentThumb = _ref$persistentThumb === void 0 ? false : _ref$persistentThumb,\n      _ref$valueToLabel = _ref.valueToLabel,\n      valueToLabel = _ref$valueToLabel === void 0 ? function (label) {\n    return label;\n  } : _ref$valueToLabel,\n      providedValue = _ref.value;\n\n  var theme = react__WEBPACK_IMPORTED_MODULE_0__.useContext(_styles_theme_provider_js__WEBPACK_IMPORTED_MODULE_2__.ThemeContext);\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      isHovered0 = _React$useState2[0],\n      setIsHovered0 = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      isHovered1 = _React$useState4[0],\n      setIsHovered1 = _React$useState4[1];\n\n  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      isFocusVisible = _React$useState6[0],\n      setIsFocusVisible = _React$useState6[1];\n\n  var _React$useState7 = react__WEBPACK_IMPORTED_MODULE_0__.useState(-1),\n      _React$useState8 = _slicedToArray(_React$useState7, 2),\n      focusedThumbIndex = _React$useState8[0],\n      setFocusedThumbIndex = _React$useState8[1];\n\n  var handleFocus = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {\n    if ((0,_utils_focusVisible_js__WEBPACK_IMPORTED_MODULE_3__.isFocusVisible)(event)) {\n      setIsFocusVisible(true);\n    }\n\n    var index = // flowlint-next-line unclear-type:off\n    event.target.parentNode.firstChild === event.target ? 0 : 1;\n    setFocusedThumbIndex(index);\n  }, []);\n  var handleBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event) {\n    if (isFocusVisible !== false) {\n      setIsFocusVisible(false);\n    }\n\n    setFocusedThumbIndex(-1);\n  }, []);\n  var value = limitValue(providedValue);\n  var sharedProps = {\n    $disabled: disabled,\n    $step: step,\n    $min: min,\n    $max: max,\n    $marks: marks,\n    $value: value,\n    $isFocusVisible: isFocusVisible\n  };\n\n  var _getOverrides = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Root, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.Root),\n      _getOverrides2 = _slicedToArray(_getOverrides, 2),\n      Root = _getOverrides2[0],\n      rootProps = _getOverrides2[1];\n\n  var _getOverrides3 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Track, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.Track),\n      _getOverrides4 = _slicedToArray(_getOverrides3, 2),\n      Track = _getOverrides4[0],\n      trackProps = _getOverrides4[1];\n\n  var _getOverrides5 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.InnerTrack, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.InnerTrack),\n      _getOverrides6 = _slicedToArray(_getOverrides5, 2),\n      InnerTrack = _getOverrides6[0],\n      innerTrackProps = _getOverrides6[1];\n\n  var _getOverrides7 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Thumb, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.Thumb),\n      _getOverrides8 = _slicedToArray(_getOverrides7, 2),\n      Thumb = _getOverrides8[0],\n      thumbProps = _getOverrides8[1];\n\n  var _getOverrides9 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.InnerThumb, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.InnerThumb),\n      _getOverrides10 = _slicedToArray(_getOverrides9, 2),\n      InnerThumb = _getOverrides10[0],\n      innerThumbProps = _getOverrides10[1];\n\n  var _getOverrides11 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.ThumbValue, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.ThumbValue),\n      _getOverrides12 = _slicedToArray(_getOverrides11, 2),\n      ThumbValue = _getOverrides12[0],\n      thumbValueProps = _getOverrides12[1];\n\n  var _getOverrides13 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Tick, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.Tick),\n      _getOverrides14 = _slicedToArray(_getOverrides13, 2),\n      Tick = _getOverrides14[0],\n      tickProps = _getOverrides14[1];\n\n  var _getOverrides15 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.TickBar, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.TickBar),\n      _getOverrides16 = _slicedToArray(_getOverrides15, 2),\n      TickBar = _getOverrides16[0],\n      tickBarProps = _getOverrides16[1];\n\n  var _getOverrides17 = (0,_helpers_overrides_js__WEBPACK_IMPORTED_MODULE_4__.getOverrides)(overrides.Mark, _styled_components_js__WEBPACK_IMPORTED_MODULE_5__.Mark),\n      _getOverrides18 = _slicedToArray(_getOverrides17, 2),\n      Mark = _getOverrides18[0],\n      markProps = _getOverrides18[1];\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Root, _extends({\n    \"data-baseweb\": \"slider\"\n  }, sharedProps, rootProps, {\n    onFocus: (0,_utils_focusVisible_js__WEBPACK_IMPORTED_MODULE_3__.forkFocus)(rootProps, handleFocus),\n    onBlur: (0,_utils_focusVisible_js__WEBPACK_IMPORTED_MODULE_3__.forkBlur)(rootProps, handleBlur)\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_range__WEBPACK_IMPORTED_MODULE_1__.Range, _extends({\n    step: step,\n    min: min,\n    max: max,\n    values: value,\n    disabled: disabled,\n    onChange: function onChange(value) {\n      return _onChange({\n        value: value\n      });\n    },\n    onFinalChange: function onFinalChange(value) {\n      return _onFinalChange({\n        value: value\n      });\n    },\n    rtl: theme.direction === 'rtl',\n    renderTrack: function renderTrack(_ref2) {\n      var props = _ref2.props,\n          children = _ref2.children,\n          isDragged = _ref2.isDragged;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Track, _extends({\n        onMouseDown: props.onMouseDown,\n        onTouchStart: props.onTouchStart,\n        $isDragged: isDragged\n      }, sharedProps, trackProps), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerTrack, _extends({\n        $isDragged: isDragged,\n        ref: props.ref\n      }, sharedProps, innerTrackProps), children));\n    },\n    renderThumb: function renderThumb(_ref3) {\n      var props = _ref3.props,\n          index = _ref3.index,\n          isDragged = _ref3.isDragged;\n      var displayLabel = persistentThumb ? persistentThumb : (!!index && isHovered1 || !index && isHovered0 || isDragged) && !disabled;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Thumb, _extends({}, props, {\n        onMouseEnter: function onMouseEnter() {\n          if (index === 0) {\n            setIsHovered0(true);\n          } else {\n            setIsHovered1(true);\n          }\n        },\n        onMouseLeave: function onMouseLeave() {\n          if (index === 0) {\n            setIsHovered0(false);\n          } else {\n            setIsHovered1(false);\n          }\n        },\n        $thumbIndex: index,\n        $isDragged: isDragged,\n        style: _objectSpread({}, props.style)\n      }, sharedProps, thumbProps, {\n        $isFocusVisible: isFocusVisible && focusedThumbIndex === index\n      }), displayLabel && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ThumbValue, _extends({\n        $thumbIndex: index,\n        $isDragged: isDragged\n      }, sharedProps, thumbValueProps), valueToLabel(value[index])), displayLabel && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(InnerThumb, _extends({\n        $thumbIndex: index,\n        $isDragged: isDragged\n      }, sharedProps, innerThumbProps)));\n    }\n  }, marks ? {\n    // eslint-disable-next-line react/display-name\n    renderMark: function renderMark(_ref4) {\n      var props = _ref4.props,\n          index = _ref4.index;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Mark, _extends({\n        $markIndex: index\n      }, props, sharedProps, markProps));\n    }\n  } : {})), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(TickBar, _extends({}, sharedProps, tickBarProps), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tick, _extends({}, sharedProps, tickProps), valueToLabel(min)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tick, _extends({}, sharedProps, tickProps), valueToLabel(max))));\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Slider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc2xpZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsaUVBQWlFLEdBQUcsa0NBQWtDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPOztBQUV0Z0IsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNLHNCQUFzQixnREFBZ0QsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7O0FBRXBSLGtDQUFrQzs7QUFFbEMsOEJBQThCOztBQUU5QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1MsdUNBQXVDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLG9CQUFvQjs7QUFFeksseUNBQXlDLGdGQUFnRixlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRTNkLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDK0I7QUFDSztBQUMyRDtBQUMySztBQUNuTjtBQUNJLENBQUM7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGNBQWMsNkNBQWdCLENBQUMsbUVBQVk7O0FBRTNDLHdCQUF3QiwyQ0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLDJDQUFjO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsMkNBQWM7QUFDdkM7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwyQ0FBYztBQUN2QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDhDQUFpQjtBQUNyQyxRQUFRLHNFQUFZO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQiw4Q0FBaUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtRUFBWSxpQkFBaUIsdURBQVU7QUFDN0Q7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtRUFBWSxrQkFBa0Isd0RBQVc7QUFDaEU7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtRUFBWSx1QkFBdUIsNkRBQWdCO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUVBQVksa0JBQWtCLHdEQUFXO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUVBQVksdUJBQXVCLDZEQUFnQjtBQUMxRTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1FQUFZLHVCQUF1Qiw2REFBZ0I7QUFDM0U7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtRUFBWSxpQkFBaUIsdURBQVU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtRUFBWSxvQkFBb0IsMERBQWE7QUFDckU7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtRUFBWSxpQkFBaUIsdURBQVU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHO0FBQ0gsYUFBYSxpRUFBUztBQUN0QixZQUFZLGdFQUFRO0FBQ3BCLEdBQUcsZ0JBQWdCLGdEQUFtQixDQUFDLDhDQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnREFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsT0FBTyx5Q0FBeUMsZ0RBQW1CO0FBQ25FO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQW1CLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLE9BQU87QUFDUDtBQUNBLE9BQU8sZ0NBQWdDLGdEQUFtQjtBQUMxRDtBQUNBO0FBQ0EsT0FBTywyRkFBMkYsZ0RBQW1CO0FBQ3JIO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQW1CO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSSxJQUFJLGlCQUFpQixnREFBbUIscUJBQXFCLDJDQUEyQyxnREFBbUIsa0JBQWtCLDREQUE0RCxnREFBbUIsa0JBQWtCO0FBQ2xQOztBQUVBLCtEQUFlLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2V1aS9lc20vc2xpZGVyL3NsaWRlci5qcz9hODg3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG4vKlxuQ29weXJpZ2h0IChjKSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuXG5UaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbkxJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJ3JlYWN0LXJhbmdlJztcbmltcG9ydCB7IGlzRm9jdXNWaXNpYmxlIGFzIGZvY3VzVmlzaWJsZSwgZm9ya0ZvY3VzLCBmb3JrQmx1ciB9IGZyb20gJy4uL3V0aWxzL2ZvY3VzVmlzaWJsZS5qcyc7XG5pbXBvcnQgeyBSb290IGFzIFN0eWxlZFJvb3QsIFRyYWNrIGFzIFN0eWxlZFRyYWNrLCBJbm5lclRyYWNrIGFzIFN0eWxlZElubmVyVHJhY2ssIFRpY2sgYXMgU3R5bGVkVGljaywgVGlja0JhciBhcyBTdHlsZWRUaWNrQmFyLCBUaHVtYiBhcyBTdHlsZWRUaHVtYiwgSW5uZXJUaHVtYiBhcyBTdHlsZWRJbm5lclRodW1iLCBUaHVtYlZhbHVlIGFzIFN0eWxlZFRodW1iVmFsdWUsIE1hcmsgYXMgU3R5bGVkTWFyayB9IGZyb20gJy4vc3R5bGVkLWNvbXBvbmVudHMuanMnO1xuaW1wb3J0IHsgZ2V0T3ZlcnJpZGVzIH0gZnJvbSAnLi4vaGVscGVycy9vdmVycmlkZXMuanMnO1xuaW1wb3J0IHsgVGhlbWVDb250ZXh0IH0gZnJvbSAnLi4vc3R5bGVzL3RoZW1lLXByb3ZpZGVyLmpzJzsgLy8gdmFsdWUubGVuZ3RoIHNob3VsZCBub3QgYmUgYmlnZ2VyIHRoYW4gdHdvXG4vLyBiZWNhdXNlIG91ciBkZXNpZ24gZG9lc24ndCBzdXBwb3J0IG1vcmUgdGhhblxuLy8gdHdvIHRodW1ic1xuXG52YXIgbGltaXRWYWx1ZSA9IGZ1bmN0aW9uIGxpbWl0VmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgdmFsdWUgcHJvcCByZXByZXNlbnRzIHBvc2l0aW9ucyBvZiB0aHVtYnMsIHNvIGl0cyBsZW5ndGggY2FuIGJlIG9ubHkgb25lIG9yIHR3bycpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZnVuY3Rpb24gU2xpZGVyKF9yZWYpIHtcbiAgdmFyIF9yZWYkb3ZlcnJpZGVzID0gX3JlZi5vdmVycmlkZXMsXG4gICAgICBvdmVycmlkZXMgPSBfcmVmJG92ZXJyaWRlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG92ZXJyaWRlcyxcbiAgICAgIF9yZWYkZGlzYWJsZWQgPSBfcmVmLmRpc2FibGVkLFxuICAgICAgZGlzYWJsZWQgPSBfcmVmJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGlzYWJsZWQsXG4gICAgICBfcmVmJG1hcmtzID0gX3JlZi5tYXJrcyxcbiAgICAgIG1hcmtzID0gX3JlZiRtYXJrcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJG1hcmtzLFxuICAgICAgX3JlZiRvbkNoYW5nZSA9IF9yZWYub25DaGFuZ2UsXG4gICAgICBfb25DaGFuZ2UgPSBfcmVmJG9uQ2hhbmdlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF9yZWYkb25DaGFuZ2UsXG4gICAgICBfcmVmJG9uRmluYWxDaGFuZ2UgPSBfcmVmLm9uRmluYWxDaGFuZ2UsXG4gICAgICBfb25GaW5hbENoYW5nZSA9IF9yZWYkb25GaW5hbENoYW5nZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmJG9uRmluYWxDaGFuZ2UsXG4gICAgICBfcmVmJG1pbiA9IF9yZWYubWluLFxuICAgICAgbWluID0gX3JlZiRtaW4gPT09IHZvaWQgMCA/IDAgOiBfcmVmJG1pbixcbiAgICAgIF9yZWYkbWF4ID0gX3JlZi5tYXgsXG4gICAgICBtYXggPSBfcmVmJG1heCA9PT0gdm9pZCAwID8gMTAwIDogX3JlZiRtYXgsXG4gICAgICBfcmVmJHN0ZXAgPSBfcmVmLnN0ZXAsXG4gICAgICBzdGVwID0gX3JlZiRzdGVwID09PSB2b2lkIDAgPyAxIDogX3JlZiRzdGVwLFxuICAgICAgX3JlZiRwZXJzaXN0ZW50VGh1bWIgPSBfcmVmLnBlcnNpc3RlbnRUaHVtYixcbiAgICAgIHBlcnNpc3RlbnRUaHVtYiA9IF9yZWYkcGVyc2lzdGVudFRodW1iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkcGVyc2lzdGVudFRodW1iLFxuICAgICAgX3JlZiR2YWx1ZVRvTGFiZWwgPSBfcmVmLnZhbHVlVG9MYWJlbCxcbiAgICAgIHZhbHVlVG9MYWJlbCA9IF9yZWYkdmFsdWVUb0xhYmVsID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH0gOiBfcmVmJHZhbHVlVG9MYWJlbCxcbiAgICAgIHByb3ZpZGVkVmFsdWUgPSBfcmVmLnZhbHVlO1xuXG4gIHZhciB0aGVtZSA9IFJlYWN0LnVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBpc0hvdmVyZWQwID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldElzSG92ZXJlZDAgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZTMsIDIpLFxuICAgICAgaXNIb3ZlcmVkMSA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRJc0hvdmVyZWQxID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGU1LCAyKSxcbiAgICAgIGlzRm9jdXNWaXNpYmxlID0gX1JlYWN0JHVzZVN0YXRlNlswXSxcbiAgICAgIHNldElzRm9jdXNWaXNpYmxlID0gX1JlYWN0JHVzZVN0YXRlNlsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlNyA9IFJlYWN0LnVzZVN0YXRlKC0xKSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTggPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGU3LCAyKSxcbiAgICAgIGZvY3VzZWRUaHVtYkluZGV4ID0gX1JlYWN0JHVzZVN0YXRlOFswXSxcbiAgICAgIHNldEZvY3VzZWRUaHVtYkluZGV4ID0gX1JlYWN0JHVzZVN0YXRlOFsxXTtcblxuICB2YXIgaGFuZGxlRm9jdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZm9jdXNWaXNpYmxlKGV2ZW50KSkge1xuICAgICAgc2V0SXNGb2N1c1Zpc2libGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICBldmVudC50YXJnZXQucGFyZW50Tm9kZS5maXJzdENoaWxkID09PSBldmVudC50YXJnZXQgPyAwIDogMTtcbiAgICBzZXRGb2N1c2VkVGh1bWJJbmRleChpbmRleCk7XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZUJsdXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoaXNGb2N1c1Zpc2libGUgIT09IGZhbHNlKSB7XG4gICAgICBzZXRJc0ZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXNlZFRodW1iSW5kZXgoLTEpO1xuICB9LCBbXSk7XG4gIHZhciB2YWx1ZSA9IGxpbWl0VmFsdWUocHJvdmlkZWRWYWx1ZSk7XG4gIHZhciBzaGFyZWRQcm9wcyA9IHtcbiAgICAkZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICRzdGVwOiBzdGVwLFxuICAgICRtaW46IG1pbixcbiAgICAkbWF4OiBtYXgsXG4gICAgJG1hcmtzOiBtYXJrcyxcbiAgICAkdmFsdWU6IHZhbHVlLFxuICAgICRpc0ZvY3VzVmlzaWJsZTogaXNGb2N1c1Zpc2libGVcbiAgfTtcblxuICB2YXIgX2dldE92ZXJyaWRlcyA9IGdldE92ZXJyaWRlcyhvdmVycmlkZXMuUm9vdCwgU3R5bGVkUm9vdCksXG4gICAgICBfZ2V0T3ZlcnJpZGVzMiA9IF9zbGljZWRUb0FycmF5KF9nZXRPdmVycmlkZXMsIDIpLFxuICAgICAgUm9vdCA9IF9nZXRPdmVycmlkZXMyWzBdLFxuICAgICAgcm9vdFByb3BzID0gX2dldE92ZXJyaWRlczJbMV07XG5cbiAgdmFyIF9nZXRPdmVycmlkZXMzID0gZ2V0T3ZlcnJpZGVzKG92ZXJyaWRlcy5UcmFjaywgU3R5bGVkVHJhY2spLFxuICAgICAgX2dldE92ZXJyaWRlczQgPSBfc2xpY2VkVG9BcnJheShfZ2V0T3ZlcnJpZGVzMywgMiksXG4gICAgICBUcmFjayA9IF9nZXRPdmVycmlkZXM0WzBdLFxuICAgICAgdHJhY2tQcm9wcyA9IF9nZXRPdmVycmlkZXM0WzFdO1xuXG4gIHZhciBfZ2V0T3ZlcnJpZGVzNSA9IGdldE92ZXJyaWRlcyhvdmVycmlkZXMuSW5uZXJUcmFjaywgU3R5bGVkSW5uZXJUcmFjayksXG4gICAgICBfZ2V0T3ZlcnJpZGVzNiA9IF9zbGljZWRUb0FycmF5KF9nZXRPdmVycmlkZXM1LCAyKSxcbiAgICAgIElubmVyVHJhY2sgPSBfZ2V0T3ZlcnJpZGVzNlswXSxcbiAgICAgIGlubmVyVHJhY2tQcm9wcyA9IF9nZXRPdmVycmlkZXM2WzFdO1xuXG4gIHZhciBfZ2V0T3ZlcnJpZGVzNyA9IGdldE92ZXJyaWRlcyhvdmVycmlkZXMuVGh1bWIsIFN0eWxlZFRodW1iKSxcbiAgICAgIF9nZXRPdmVycmlkZXM4ID0gX3NsaWNlZFRvQXJyYXkoX2dldE92ZXJyaWRlczcsIDIpLFxuICAgICAgVGh1bWIgPSBfZ2V0T3ZlcnJpZGVzOFswXSxcbiAgICAgIHRodW1iUHJvcHMgPSBfZ2V0T3ZlcnJpZGVzOFsxXTtcblxuICB2YXIgX2dldE92ZXJyaWRlczkgPSBnZXRPdmVycmlkZXMob3ZlcnJpZGVzLklubmVyVGh1bWIsIFN0eWxlZElubmVyVGh1bWIpLFxuICAgICAgX2dldE92ZXJyaWRlczEwID0gX3NsaWNlZFRvQXJyYXkoX2dldE92ZXJyaWRlczksIDIpLFxuICAgICAgSW5uZXJUaHVtYiA9IF9nZXRPdmVycmlkZXMxMFswXSxcbiAgICAgIGlubmVyVGh1bWJQcm9wcyA9IF9nZXRPdmVycmlkZXMxMFsxXTtcblxuICB2YXIgX2dldE92ZXJyaWRlczExID0gZ2V0T3ZlcnJpZGVzKG92ZXJyaWRlcy5UaHVtYlZhbHVlLCBTdHlsZWRUaHVtYlZhbHVlKSxcbiAgICAgIF9nZXRPdmVycmlkZXMxMiA9IF9zbGljZWRUb0FycmF5KF9nZXRPdmVycmlkZXMxMSwgMiksXG4gICAgICBUaHVtYlZhbHVlID0gX2dldE92ZXJyaWRlczEyWzBdLFxuICAgICAgdGh1bWJWYWx1ZVByb3BzID0gX2dldE92ZXJyaWRlczEyWzFdO1xuXG4gIHZhciBfZ2V0T3ZlcnJpZGVzMTMgPSBnZXRPdmVycmlkZXMob3ZlcnJpZGVzLlRpY2ssIFN0eWxlZFRpY2spLFxuICAgICAgX2dldE92ZXJyaWRlczE0ID0gX3NsaWNlZFRvQXJyYXkoX2dldE92ZXJyaWRlczEzLCAyKSxcbiAgICAgIFRpY2sgPSBfZ2V0T3ZlcnJpZGVzMTRbMF0sXG4gICAgICB0aWNrUHJvcHMgPSBfZ2V0T3ZlcnJpZGVzMTRbMV07XG5cbiAgdmFyIF9nZXRPdmVycmlkZXMxNSA9IGdldE92ZXJyaWRlcyhvdmVycmlkZXMuVGlja0JhciwgU3R5bGVkVGlja0JhciksXG4gICAgICBfZ2V0T3ZlcnJpZGVzMTYgPSBfc2xpY2VkVG9BcnJheShfZ2V0T3ZlcnJpZGVzMTUsIDIpLFxuICAgICAgVGlja0JhciA9IF9nZXRPdmVycmlkZXMxNlswXSxcbiAgICAgIHRpY2tCYXJQcm9wcyA9IF9nZXRPdmVycmlkZXMxNlsxXTtcblxuICB2YXIgX2dldE92ZXJyaWRlczE3ID0gZ2V0T3ZlcnJpZGVzKG92ZXJyaWRlcy5NYXJrLCBTdHlsZWRNYXJrKSxcbiAgICAgIF9nZXRPdmVycmlkZXMxOCA9IF9zbGljZWRUb0FycmF5KF9nZXRPdmVycmlkZXMxNywgMiksXG4gICAgICBNYXJrID0gX2dldE92ZXJyaWRlczE4WzBdLFxuICAgICAgbWFya1Byb3BzID0gX2dldE92ZXJyaWRlczE4WzFdO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb290LCBfZXh0ZW5kcyh7XG4gICAgXCJkYXRhLWJhc2V3ZWJcIjogXCJzbGlkZXJcIlxuICB9LCBzaGFyZWRQcm9wcywgcm9vdFByb3BzLCB7XG4gICAgb25Gb2N1czogZm9ya0ZvY3VzKHJvb3RQcm9wcywgaGFuZGxlRm9jdXMpLFxuICAgIG9uQmx1cjogZm9ya0JsdXIocm9vdFByb3BzLCBoYW5kbGVCbHVyKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmFuZ2UsIF9leHRlbmRzKHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIHZhbHVlczogdmFsdWUsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIF9vbkNoYW5nZSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkZpbmFsQ2hhbmdlOiBmdW5jdGlvbiBvbkZpbmFsQ2hhbmdlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX29uRmluYWxDaGFuZ2Uoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcnRsOiB0aGVtZS5kaXJlY3Rpb24gPT09ICdydGwnLFxuICAgIHJlbmRlclRyYWNrOiBmdW5jdGlvbiByZW5kZXJUcmFjayhfcmVmMikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICAgICAgICBpc0RyYWdnZWQgPSBfcmVmMi5pc0RyYWdnZWQ7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhY2ssIF9leHRlbmRzKHtcbiAgICAgICAgb25Nb3VzZURvd246IHByb3BzLm9uTW91c2VEb3duLFxuICAgICAgICBvblRvdWNoU3RhcnQ6IHByb3BzLm9uVG91Y2hTdGFydCxcbiAgICAgICAgJGlzRHJhZ2dlZDogaXNEcmFnZ2VkXG4gICAgICB9LCBzaGFyZWRQcm9wcywgdHJhY2tQcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KElubmVyVHJhY2ssIF9leHRlbmRzKHtcbiAgICAgICAgJGlzRHJhZ2dlZDogaXNEcmFnZ2VkLFxuICAgICAgICByZWY6IHByb3BzLnJlZlxuICAgICAgfSwgc2hhcmVkUHJvcHMsIGlubmVyVHJhY2tQcm9wcyksIGNoaWxkcmVuKSk7XG4gICAgfSxcbiAgICByZW5kZXJUaHVtYjogZnVuY3Rpb24gcmVuZGVyVGh1bWIoX3JlZjMpIHtcbiAgICAgIHZhciBwcm9wcyA9IF9yZWYzLnByb3BzLFxuICAgICAgICAgIGluZGV4ID0gX3JlZjMuaW5kZXgsXG4gICAgICAgICAgaXNEcmFnZ2VkID0gX3JlZjMuaXNEcmFnZ2VkO1xuICAgICAgdmFyIGRpc3BsYXlMYWJlbCA9IHBlcnNpc3RlbnRUaHVtYiA/IHBlcnNpc3RlbnRUaHVtYiA6ICghIWluZGV4ICYmIGlzSG92ZXJlZDEgfHwgIWluZGV4ICYmIGlzSG92ZXJlZDAgfHwgaXNEcmFnZ2VkKSAmJiAhZGlzYWJsZWQ7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGh1bWIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHNldElzSG92ZXJlZDAodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldElzSG92ZXJlZDEodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHNldElzSG92ZXJlZDAoZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRJc0hvdmVyZWQxKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICR0aHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgJGlzRHJhZ2dlZDogaXNEcmFnZ2VkLFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7fSwgcHJvcHMuc3R5bGUpXG4gICAgICB9LCBzaGFyZWRQcm9wcywgdGh1bWJQcm9wcywge1xuICAgICAgICAkaXNGb2N1c1Zpc2libGU6IGlzRm9jdXNWaXNpYmxlICYmIGZvY3VzZWRUaHVtYkluZGV4ID09PSBpbmRleFxuICAgICAgfSksIGRpc3BsYXlMYWJlbCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUaHVtYlZhbHVlLCBfZXh0ZW5kcyh7XG4gICAgICAgICR0aHVtYkluZGV4OiBpbmRleCxcbiAgICAgICAgJGlzRHJhZ2dlZDogaXNEcmFnZ2VkXG4gICAgICB9LCBzaGFyZWRQcm9wcywgdGh1bWJWYWx1ZVByb3BzKSwgdmFsdWVUb0xhYmVsKHZhbHVlW2luZGV4XSkpLCBkaXNwbGF5TGFiZWwgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSW5uZXJUaHVtYiwgX2V4dGVuZHMoe1xuICAgICAgICAkdGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICRpc0RyYWdnZWQ6IGlzRHJhZ2dlZFxuICAgICAgfSwgc2hhcmVkUHJvcHMsIGlubmVyVGh1bWJQcm9wcykpKTtcbiAgICB9XG4gIH0sIG1hcmtzID8ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZW5kZXJNYXJrOiBmdW5jdGlvbiByZW5kZXJNYXJrKF9yZWY0KSB7XG4gICAgICB2YXIgcHJvcHMgPSBfcmVmNC5wcm9wcyxcbiAgICAgICAgICBpbmRleCA9IF9yZWY0LmluZGV4O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1hcmssIF9leHRlbmRzKHtcbiAgICAgICAgJG1hcmtJbmRleDogaW5kZXhcbiAgICAgIH0sIHByb3BzLCBzaGFyZWRQcm9wcywgbWFya1Byb3BzKSk7XG4gICAgfVxuICB9IDoge30pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGlja0JhciwgX2V4dGVuZHMoe30sIHNoYXJlZFByb3BzLCB0aWNrQmFyUHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUaWNrLCBfZXh0ZW5kcyh7fSwgc2hhcmVkUHJvcHMsIHRpY2tQcm9wcyksIHZhbHVlVG9MYWJlbChtaW4pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGljaywgX2V4dGVuZHMoe30sIHNoYXJlZFByb3BzLCB0aWNrUHJvcHMpLCB2YWx1ZVRvTGFiZWwobWF4KSkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/slider.js\n");

/***/ }),

/***/ "./node_modules/baseui/esm/slider/stateful-slider-container.js":
/*!*********************************************************************!*\
  !*** ./node_modules/baseui/esm/slider/stateful-slider-container.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ \"./node_modules/baseui/esm/slider/constants.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\n\nvar defaultStateReducer = function defaultStateReducer(type, nextState) {\n  return nextState;\n};\n\nvar StatefulSliderContainer = /*#__PURE__*/function (_React$Component) {\n  _inherits(StatefulSliderContainer, _React$Component);\n\n  var _super = _createSuper(StatefulSliderContainer);\n\n  function StatefulSliderContainer(props) {\n    var _this;\n\n    _classCallCheck(this, StatefulSliderContainer);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"onChange\", function (params) {\n      _this.internalSetState(_constants_js__WEBPACK_IMPORTED_MODULE_1__.STATE_CHANGE_TYPE.change, params);\n\n      return _this.props.onChange(_objectSpread({}, params));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onFinalChange\", function (params) {\n      _this.internalSetState(_constants_js__WEBPACK_IMPORTED_MODULE_1__.STATE_CHANGE_TYPE.finalChange, params);\n\n      return _this.props.onFinalChange(_objectSpread({}, params));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"internalSetState\", function (type, _ref) {\n      var value = _ref.value;\n      var nextState = {\n        value: value\n      };\n      var stateReducer = _this.props.stateReducer;\n      var newState = stateReducer(type, nextState, _this.state);\n\n      _this.setState(newState);\n    });\n\n    _this.state = {\n      value: props.initialState && Array.isArray(props.initialState.value) ? props.initialState.value : [Math.round((props.max - props.min) / 2) + props.min]\n    };\n    return _this;\n  }\n\n  _createClass(StatefulSliderContainer, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          initialState = _this$props.initialState,\n          stateReducer = _this$props.stateReducer,\n          restProps = _objectWithoutProperties(_this$props, [\"children\", \"initialState\", \"stateReducer\"]);\n\n      return children(_objectSpread(_objectSpread(_objectSpread({}, restProps), this.state), {}, {\n        onChange: this.onChange,\n        onFinalChange: this.onFinalChange\n      }));\n    }\n  }]);\n\n  return StatefulSliderContainer;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n_defineProperty(StatefulSliderContainer, \"defaultProps\", {\n  stateReducer: defaultStateReducer,\n  min: 0,\n  max: 100,\n  step: 1,\n  marks: false,\n  onChange: function onChange() {},\n  onFinalChange: function onFinalChange() {}\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StatefulSliderContainer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc3RhdGVmdWwtc2xpZGVyLWNvbnRhaW5lci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsd0JBQXdCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLHdCQUF3QixPQUFPLGtDQUFrQyxtSUFBbUk7O0FBRXBXLHNEQUFzRCwrQkFBK0IsOERBQThELFlBQVksb0NBQW9DLDZEQUE2RCxZQUFZLDZCQUE2QixPQUFPLDJCQUEyQiwwQ0FBMEMsd0VBQXdFLCtCQUErQjs7QUFFNWQsMkRBQTJELCtCQUErQixpQkFBaUIsc0NBQXNDLFlBQVksWUFBWSx1QkFBdUIsT0FBTyxxQkFBcUIsMENBQTBDLDZCQUE2Qjs7QUFFblMsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxpRUFBaUUsR0FBRyxrQ0FBa0M7O0FBRXZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsdURBQXVELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxpREFBaUQsbUZBQW1GLE9BQU87O0FBRXRnQixrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQ7O0FBRWxNLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHOztBQUV6VSxpQ0FBaUMsNEVBQTRFLGlCQUFpQixhQUFhOztBQUUzSSxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZTs7QUFFM0ksd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLHVFQUF1RSxJQUFJLGVBQWUsWUFBWTs7QUFFblQsOEJBQThCLGdHQUFnRyxtREFBbUQ7O0FBRWpMLDRDQUE0QyxrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9COztBQUVwTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUMrQjtBQUNvQjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QixtRUFBd0I7O0FBRXJELGtEQUFrRDtBQUNsRCxLQUFLOztBQUVMO0FBQ0EsNkJBQTZCLHdFQUE2Qjs7QUFFMUQsdURBQXVEO0FBQ3ZELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLDRDQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxDQUFDOztBQUVELCtEQUFlLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc3RhdGVmdWwtc2xpZGVyLWNvbnRhaW5lci5qcz9lMDg1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qXG5Db3B5cmlnaHQgKGMpIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cblRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFNUQVRFX0NIQU5HRV9UWVBFIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG52YXIgZGVmYXVsdFN0YXRlUmVkdWNlciA9IGZ1bmN0aW9uIGRlZmF1bHRTdGF0ZVJlZHVjZXIodHlwZSwgbmV4dFN0YXRlKSB7XG4gIHJldHVybiBuZXh0U3RhdGU7XG59O1xuXG52YXIgU3RhdGVmdWxTbGlkZXJDb250YWluZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFN0YXRlZnVsU2xpZGVyQ29udGFpbmVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFN0YXRlZnVsU2xpZGVyQ29udGFpbmVyKTtcblxuICBmdW5jdGlvbiBTdGF0ZWZ1bFNsaWRlckNvbnRhaW5lcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZWZ1bFNsaWRlckNvbnRhaW5lcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvbkNoYW5nZVwiLCBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICBfdGhpcy5pbnRlcm5hbFNldFN0YXRlKFNUQVRFX0NIQU5HRV9UWVBFLmNoYW5nZSwgcGFyYW1zKTtcblxuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uQ2hhbmdlKF9vYmplY3RTcHJlYWQoe30sIHBhcmFtcykpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRmluYWxDaGFuZ2VcIiwgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgX3RoaXMuaW50ZXJuYWxTZXRTdGF0ZShTVEFURV9DSEFOR0VfVFlQRS5maW5hbENoYW5nZSwgcGFyYW1zKTtcblxuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9uRmluYWxDaGFuZ2UoX29iamVjdFNwcmVhZCh7fSwgcGFyYW1zKSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW50ZXJuYWxTZXRTdGF0ZVwiLCBmdW5jdGlvbiAodHlwZSwgX3JlZikge1xuICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICAgIHZhciBzdGF0ZVJlZHVjZXIgPSBfdGhpcy5wcm9wcy5zdGF0ZVJlZHVjZXI7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBzdGF0ZVJlZHVjZXIodHlwZSwgbmV4dFN0YXRlLCBfdGhpcy5zdGF0ZSk7XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9KTtcblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdmFsdWU6IHByb3BzLmluaXRpYWxTdGF0ZSAmJiBBcnJheS5pc0FycmF5KHByb3BzLmluaXRpYWxTdGF0ZS52YWx1ZSkgPyBwcm9wcy5pbml0aWFsU3RhdGUudmFsdWUgOiBbTWF0aC5yb3VuZCgocHJvcHMubWF4IC0gcHJvcHMubWluKSAvIDIpICsgcHJvcHMubWluXVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXRlZnVsU2xpZGVyQ29udGFpbmVyLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IF90aGlzJHByb3BzLmluaXRpYWxTdGF0ZSxcbiAgICAgICAgICBzdGF0ZVJlZHVjZXIgPSBfdGhpcyRwcm9wcy5zdGF0ZVJlZHVjZXIsXG4gICAgICAgICAgcmVzdFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjaGlsZHJlblwiLCBcImluaXRpYWxTdGF0ZVwiLCBcInN0YXRlUmVkdWNlclwiXSk7XG5cbiAgICAgIHJldHVybiBjaGlsZHJlbihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdFByb3BzKSwgdGhpcy5zdGF0ZSksIHt9LCB7XG4gICAgICAgIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICBvbkZpbmFsQ2hhbmdlOiB0aGlzLm9uRmluYWxDaGFuZ2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RhdGVmdWxTbGlkZXJDb250YWluZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbl9kZWZpbmVQcm9wZXJ0eShTdGF0ZWZ1bFNsaWRlckNvbnRhaW5lciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBzdGF0ZVJlZHVjZXI6IGRlZmF1bHRTdGF0ZVJlZHVjZXIsXG4gIG1pbjogMCxcbiAgbWF4OiAxMDAsXG4gIHN0ZXA6IDEsXG4gIG1hcmtzOiBmYWxzZSxcbiAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCkge30sXG4gIG9uRmluYWxDaGFuZ2U6IGZ1bmN0aW9uIG9uRmluYWxDaGFuZ2UoKSB7fVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRlZnVsU2xpZGVyQ29udGFpbmVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/stateful-slider-container.js\n");

/***/ }),

/***/ "./node_modules/baseui/esm/slider/stateful-slider.js":
/*!***********************************************************!*\
  !*** ./node_modules/baseui/esm/slider/stateful-slider.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ StatefulSlider; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stateful_slider_container_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stateful-slider-container.js */ \"./node_modules/baseui/esm/slider/stateful-slider-container.js\");\n/* harmony import */ var _slider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slider.js */ \"./node_modules/baseui/esm/slider/slider.js\");\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\n\nfunction StatefulSlider(props) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_stateful_slider_container_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], props, function (childrenProps) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_slider_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], childrenProps);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc3RhdGVmdWwtc2xpZGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDK0I7QUFDc0M7QUFDcEM7QUFDbEI7QUFDZixzQkFBc0IsZ0RBQW1CLENBQUMscUVBQXVCO0FBQ2pFLHdCQUF3QixnREFBbUIsQ0FBQyxrREFBTTtBQUNsRCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2V1aS9lc20vc2xpZGVyL3N0YXRlZnVsLXNsaWRlci5qcz9lN2NmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cblRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBTdGF0ZWZ1bFNsaWRlckNvbnRhaW5lciBmcm9tICcuL3N0YXRlZnVsLXNsaWRlci1jb250YWluZXIuanMnO1xuaW1wb3J0IFNsaWRlciBmcm9tICcuL3NsaWRlci5qcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGF0ZWZ1bFNsaWRlcihwcm9wcykge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGVmdWxTbGlkZXJDb250YWluZXIsIHByb3BzLCBmdW5jdGlvbiAoY2hpbGRyZW5Qcm9wcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbGlkZXIsIGNoaWxkcmVuUHJvcHMpO1xuICB9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/stateful-slider.js\n");

/***/ }),

/***/ "./node_modules/baseui/esm/slider/styled-components.js":
/*!*************************************************************!*\
  !*** ./node_modules/baseui/esm/slider/styled-components.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InnerThumb\": function() { return /* binding */ InnerThumb; },\n/* harmony export */   \"InnerTrack\": function() { return /* binding */ InnerTrack; },\n/* harmony export */   \"Mark\": function() { return /* binding */ Mark; },\n/* harmony export */   \"Root\": function() { return /* binding */ Root; },\n/* harmony export */   \"Thumb\": function() { return /* binding */ Thumb; },\n/* harmony export */   \"ThumbValue\": function() { return /* binding */ ThumbValue; },\n/* harmony export */   \"Tick\": function() { return /* binding */ Tick; },\n/* harmony export */   \"TickBar\": function() { return /* binding */ TickBar; },\n/* harmony export */   \"Track\": function() { return /* binding */ Track; }\n/* harmony export */ });\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-range */ \"./node_modules/baseui/node_modules/react-range/lib/index.js\");\n/* harmony import */ var react_range__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_range__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/index.js */ \"./node_modules/baseui/esm/styles/index.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\nvar Root = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', {\n  position: 'relative',\n  width: '100%'\n});\nRoot.displayName = \"Root\";\nRoot.displayName = 'StyledRoot';\nvar Track = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $theme = props.$theme,\n      _props$$value = props.$value,\n      $value = _props$$value === void 0 ? [] : _props$$value,\n      $disabled = props.$disabled,\n      $isDragged = props.$isDragged;\n  var sizing = $theme.sizing;\n  var cursor = 'inherit';\n\n  if ($disabled) {\n    cursor = 'not-allowed';\n  } else if ($isDragged) {\n    cursor = 'grabbing';\n  } else if ($value.length === 1) {\n    cursor = 'pointer';\n  }\n\n  return {\n    paddingTop: sizing.scale600,\n    paddingBottom: sizing.scale600,\n    paddingRight: sizing.scale600,\n    paddingLeft: sizing.scale600,\n    display: 'flex',\n    cursor: cursor,\n    backgroundColor: $theme.colors.sliderTrackFill\n  };\n});\nTrack.displayName = \"Track\";\nTrack.displayName = 'StyledTrack';\nvar InnerTrack = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $theme = props.$theme,\n      _props$$value2 = props.$value,\n      $value = _props$$value2 === void 0 ? [] : _props$$value2,\n      $min = props.$min,\n      $max = props.$max,\n      $disabled = props.$disabled;\n  var colors = $theme.colors,\n      borders = $theme.borders,\n      direction = $theme.direction;\n  var borderRadius = $theme.borders.useRoundedCorners ? borders.radius100 : 0;\n  return {\n    borderTopLeftRadius: borderRadius,\n    borderTopRightRadius: borderRadius,\n    borderBottomRightRadius: borderRadius,\n    borderBottomLeftRadius: borderRadius,\n    background: (0,react_range__WEBPACK_IMPORTED_MODULE_0__.getTrackBackground)({\n      values: $value,\n      colors: $value.length === 1 ? [$disabled ? colors.borderOpaque : colors.primary, $disabled ? colors.backgroundSecondary : colors.borderOpaque] : [$disabled ? colors.backgroundSecondary : colors.borderOpaque, $disabled ? colors.borderOpaque : colors.primary, $disabled ? colors.backgroundSecondary : colors.borderOpaque],\n      min: $min || 0,\n      max: $max || 0,\n      rtl: direction === 'rtl'\n    }),\n    height: '2px',\n    width: '100%',\n    alignSelf: 'center',\n    cursor: $disabled ? 'not-allowed' : 'inherit'\n  };\n});\nInnerTrack.displayName = \"InnerTrack\";\nInnerTrack.displayName = 'StyledInnerTrack';\nvar Mark = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  return {\n    width: '4px',\n    height: '2px',\n    backgroundColor: props.$theme.colors.backgroundPrimary,\n    marginLeft: '16px'\n  };\n});\nMark.displayName = \"Mark\";\nMark.displayName = 'StyledMark';\nvar Tick = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  return _objectSpread(_objectSpread({}, props.$theme.typography.font200), {}, {\n    color: props.$theme.colors.contentPrimary\n  });\n});\nTick.displayName = \"Tick\";\nTick.displayName = 'StyledTick';\nvar TickBar = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $theme = props.$theme;\n  var sizing = $theme.sizing;\n  return {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    paddingRight: sizing.scale600,\n    paddingLeft: sizing.scale600,\n    paddingBottom: sizing.scale400\n  };\n});\nTickBar.displayName = \"TickBar\";\nTickBar.displayName = 'StyledTickBar';\nvar Thumb = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $theme = props.$theme,\n      _props$$value3 = props.$value,\n      $value = _props$$value3 === void 0 ? [] : _props$$value3,\n      $thumbIndex = props.$thumbIndex,\n      $disabled = props.$disabled;\n  var isLeft = $value.length === 2 && $thumbIndex === 0;\n  var isRight = $value.length === 2 && $thumbIndex === 1;\n\n  if ($theme.direction === 'rtl' && (isRight || isLeft)) {\n    isLeft = !isLeft;\n    isRight = !isRight;\n  }\n\n  return {\n    height: '24px',\n    width: '24px',\n    borderTopLeftRadius: '24px',\n    borderTopRightRadius: '24px',\n    borderBottomLeftRadius: '24px',\n    borderBottomRightRadius: '24px',\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleFill,\n    outline: 'none',\n    boxShadow: props.$isFocusVisible ? \"0 0 0 3px \".concat($theme.colors.accent) : '0 1px 4px rgba(0, 0, 0, 0.12)',\n    cursor: $disabled ? 'not-allowed' : 'inherit'\n  };\n});\nThumb.displayName = \"Thumb\";\nThumb.displayName = 'StyledThumb';\nvar InnerThumb = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $disabled = props.$disabled,\n      $theme = props.$theme;\n  return {\n    position: 'absolute',\n    top: '-16px',\n    width: '4px',\n    height: '20px',\n    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleInnerFill\n  };\n});\nInnerThumb.displayName = \"InnerThumb\";\nInnerThumb.displayName = 'StyledInnerThumb';\nvar ThumbValue = (0,_styles_index_js__WEBPACK_IMPORTED_MODULE_1__.styled)('div', function (props) {\n  var $disabled = props.$disabled,\n      $theme = props.$theme;\n  return _objectSpread(_objectSpread({\n    position: 'absolute',\n    top: \"-\".concat($theme.sizing.scale1400)\n  }, $theme.typography.font200), {}, {\n    backgroundColor: $disabled ? $theme.colors.sliderHandleFillDisabled : $theme.colors.sliderHandleInnerFill,\n    color: $theme.colors.contentInversePrimary,\n    paddingLeft: $theme.sizing.scale600,\n    paddingRight: $theme.sizing.scale600,\n    paddingTop: $theme.sizing.scale500,\n    paddingBottom: $theme.sizing.scale500,\n    borderBottomLeftRadius: '48px',\n    borderBottomRightRadius: '48px',\n    borderTopLeftRadius: '48px',\n    borderTopRightRadius: '48px',\n    whiteSpace: 'nowrap'\n  });\n});\nThumbValue.displayName = \"ThumbValue\";\nThumbValue.displayName = 'StyledThumbValue';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc3R5bGVkLWNvbXBvbmVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxpRUFBaUUsR0FBRyxrQ0FBa0M7O0FBRXZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsdURBQXVELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxpREFBaUQsbUZBQW1GLE9BQU87O0FBRXRnQiw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE07QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDTDtBQUNyQyxXQUFXLHdEQUFNO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNPLFlBQVksd0RBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ08saUJBQWlCLHdEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDTyxXQUFXLHdEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ08sV0FBVyx3REFBTTtBQUN4Qix1Q0FBdUMsc0NBQXNDO0FBQzdFO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ08sY0FBYyx3REFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ08sWUFBWSx3REFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNPLGlCQUFpQix3REFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNPLGlCQUFpQix3REFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZXVpL2VzbS9zbGlkZXIvc3R5bGVkLWNvbXBvbmVudHMuanM/M2Y2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLypcbkNvcHlyaWdodCAoYykgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5MSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuaW1wb3J0IHsgZ2V0VHJhY2tCYWNrZ3JvdW5kIH0gZnJvbSAncmVhY3QtcmFuZ2UnO1xuaW1wb3J0IHsgc3R5bGVkIH0gZnJvbSAnLi4vc3R5bGVzL2luZGV4LmpzJztcbmV4cG9ydCB2YXIgUm9vdCA9IHN0eWxlZCgnZGl2Jywge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgd2lkdGg6ICcxMDAlJ1xufSk7XG5Sb290LmRpc3BsYXlOYW1lID0gXCJSb290XCI7XG5Sb290LmRpc3BsYXlOYW1lID0gJ1N0eWxlZFJvb3QnO1xuZXhwb3J0IHZhciBUcmFjayA9IHN0eWxlZCgnZGl2JywgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciAkdGhlbWUgPSBwcm9wcy4kdGhlbWUsXG4gICAgICBfcHJvcHMkJHZhbHVlID0gcHJvcHMuJHZhbHVlLFxuICAgICAgJHZhbHVlID0gX3Byb3BzJCR2YWx1ZSA9PT0gdm9pZCAwID8gW10gOiBfcHJvcHMkJHZhbHVlLFxuICAgICAgJGRpc2FibGVkID0gcHJvcHMuJGRpc2FibGVkLFxuICAgICAgJGlzRHJhZ2dlZCA9IHByb3BzLiRpc0RyYWdnZWQ7XG4gIHZhciBzaXppbmcgPSAkdGhlbWUuc2l6aW5nO1xuICB2YXIgY3Vyc29yID0gJ2luaGVyaXQnO1xuXG4gIGlmICgkZGlzYWJsZWQpIHtcbiAgICBjdXJzb3IgPSAnbm90LWFsbG93ZWQnO1xuICB9IGVsc2UgaWYgKCRpc0RyYWdnZWQpIHtcbiAgICBjdXJzb3IgPSAnZ3JhYmJpbmcnO1xuICB9IGVsc2UgaWYgKCR2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBjdXJzb3IgPSAncG9pbnRlcic7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhZGRpbmdUb3A6IHNpemluZy5zY2FsZTYwMCxcbiAgICBwYWRkaW5nQm90dG9tOiBzaXppbmcuc2NhbGU2MDAsXG4gICAgcGFkZGluZ1JpZ2h0OiBzaXppbmcuc2NhbGU2MDAsXG4gICAgcGFkZGluZ0xlZnQ6IHNpemluZy5zY2FsZTYwMCxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgYmFja2dyb3VuZENvbG9yOiAkdGhlbWUuY29sb3JzLnNsaWRlclRyYWNrRmlsbFxuICB9O1xufSk7XG5UcmFjay5kaXNwbGF5TmFtZSA9IFwiVHJhY2tcIjtcblRyYWNrLmRpc3BsYXlOYW1lID0gJ1N0eWxlZFRyYWNrJztcbmV4cG9ydCB2YXIgSW5uZXJUcmFjayA9IHN0eWxlZCgnZGl2JywgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciAkdGhlbWUgPSBwcm9wcy4kdGhlbWUsXG4gICAgICBfcHJvcHMkJHZhbHVlMiA9IHByb3BzLiR2YWx1ZSxcbiAgICAgICR2YWx1ZSA9IF9wcm9wcyQkdmFsdWUyID09PSB2b2lkIDAgPyBbXSA6IF9wcm9wcyQkdmFsdWUyLFxuICAgICAgJG1pbiA9IHByb3BzLiRtaW4sXG4gICAgICAkbWF4ID0gcHJvcHMuJG1heCxcbiAgICAgICRkaXNhYmxlZCA9IHByb3BzLiRkaXNhYmxlZDtcbiAgdmFyIGNvbG9ycyA9ICR0aGVtZS5jb2xvcnMsXG4gICAgICBib3JkZXJzID0gJHRoZW1lLmJvcmRlcnMsXG4gICAgICBkaXJlY3Rpb24gPSAkdGhlbWUuZGlyZWN0aW9uO1xuICB2YXIgYm9yZGVyUmFkaXVzID0gJHRoZW1lLmJvcmRlcnMudXNlUm91bmRlZENvcm5lcnMgPyBib3JkZXJzLnJhZGl1czEwMCA6IDA7XG4gIHJldHVybiB7XG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgYmFja2dyb3VuZDogZ2V0VHJhY2tCYWNrZ3JvdW5kKHtcbiAgICAgIHZhbHVlczogJHZhbHVlLFxuICAgICAgY29sb3JzOiAkdmFsdWUubGVuZ3RoID09PSAxID8gWyRkaXNhYmxlZCA/IGNvbG9ycy5ib3JkZXJPcGFxdWUgOiBjb2xvcnMucHJpbWFyeSwgJGRpc2FibGVkID8gY29sb3JzLmJhY2tncm91bmRTZWNvbmRhcnkgOiBjb2xvcnMuYm9yZGVyT3BhcXVlXSA6IFskZGlzYWJsZWQgPyBjb2xvcnMuYmFja2dyb3VuZFNlY29uZGFyeSA6IGNvbG9ycy5ib3JkZXJPcGFxdWUsICRkaXNhYmxlZCA/IGNvbG9ycy5ib3JkZXJPcGFxdWUgOiBjb2xvcnMucHJpbWFyeSwgJGRpc2FibGVkID8gY29sb3JzLmJhY2tncm91bmRTZWNvbmRhcnkgOiBjb2xvcnMuYm9yZGVyT3BhcXVlXSxcbiAgICAgIG1pbjogJG1pbiB8fCAwLFxuICAgICAgbWF4OiAkbWF4IHx8IDAsXG4gICAgICBydGw6IGRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgICB9KSxcbiAgICBoZWlnaHQ6ICcycHgnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgYWxpZ25TZWxmOiAnY2VudGVyJyxcbiAgICBjdXJzb3I6ICRkaXNhYmxlZCA/ICdub3QtYWxsb3dlZCcgOiAnaW5oZXJpdCdcbiAgfTtcbn0pO1xuSW5uZXJUcmFjay5kaXNwbGF5TmFtZSA9IFwiSW5uZXJUcmFja1wiO1xuSW5uZXJUcmFjay5kaXNwbGF5TmFtZSA9ICdTdHlsZWRJbm5lclRyYWNrJztcbmV4cG9ydCB2YXIgTWFyayA9IHN0eWxlZCgnZGl2JywgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6ICc0cHgnLFxuICAgIGhlaWdodDogJzJweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBwcm9wcy4kdGhlbWUuY29sb3JzLmJhY2tncm91bmRQcmltYXJ5LFxuICAgIG1hcmdpbkxlZnQ6ICcxNnB4J1xuICB9O1xufSk7XG5NYXJrLmRpc3BsYXlOYW1lID0gXCJNYXJrXCI7XG5NYXJrLmRpc3BsYXlOYW1lID0gJ1N0eWxlZE1hcmsnO1xuZXhwb3J0IHZhciBUaWNrID0gc3R5bGVkKCdkaXYnLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcHJvcHMuJHRoZW1lLnR5cG9ncmFwaHkuZm9udDIwMCksIHt9LCB7XG4gICAgY29sb3I6IHByb3BzLiR0aGVtZS5jb2xvcnMuY29udGVudFByaW1hcnlcbiAgfSk7XG59KTtcblRpY2suZGlzcGxheU5hbWUgPSBcIlRpY2tcIjtcblRpY2suZGlzcGxheU5hbWUgPSAnU3R5bGVkVGljayc7XG5leHBvcnQgdmFyIFRpY2tCYXIgPSBzdHlsZWQoJ2RpdicsIGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgJHRoZW1lID0gcHJvcHMuJHRoZW1lO1xuICB2YXIgc2l6aW5nID0gJHRoZW1lLnNpemluZztcbiAgcmV0dXJuIHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBwYWRkaW5nUmlnaHQ6IHNpemluZy5zY2FsZTYwMCxcbiAgICBwYWRkaW5nTGVmdDogc2l6aW5nLnNjYWxlNjAwLFxuICAgIHBhZGRpbmdCb3R0b206IHNpemluZy5zY2FsZTQwMFxuICB9O1xufSk7XG5UaWNrQmFyLmRpc3BsYXlOYW1lID0gXCJUaWNrQmFyXCI7XG5UaWNrQmFyLmRpc3BsYXlOYW1lID0gJ1N0eWxlZFRpY2tCYXInO1xuZXhwb3J0IHZhciBUaHVtYiA9IHN0eWxlZCgnZGl2JywgZnVuY3Rpb24gKHByb3BzKSB7XG4gIHZhciAkdGhlbWUgPSBwcm9wcy4kdGhlbWUsXG4gICAgICBfcHJvcHMkJHZhbHVlMyA9IHByb3BzLiR2YWx1ZSxcbiAgICAgICR2YWx1ZSA9IF9wcm9wcyQkdmFsdWUzID09PSB2b2lkIDAgPyBbXSA6IF9wcm9wcyQkdmFsdWUzLFxuICAgICAgJHRodW1iSW5kZXggPSBwcm9wcy4kdGh1bWJJbmRleCxcbiAgICAgICRkaXNhYmxlZCA9IHByb3BzLiRkaXNhYmxlZDtcbiAgdmFyIGlzTGVmdCA9ICR2YWx1ZS5sZW5ndGggPT09IDIgJiYgJHRodW1iSW5kZXggPT09IDA7XG4gIHZhciBpc1JpZ2h0ID0gJHZhbHVlLmxlbmd0aCA9PT0gMiAmJiAkdGh1bWJJbmRleCA9PT0gMTtcblxuICBpZiAoJHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCcgJiYgKGlzUmlnaHQgfHwgaXNMZWZ0KSkge1xuICAgIGlzTGVmdCA9ICFpc0xlZnQ7XG4gICAgaXNSaWdodCA9ICFpc1JpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6ICcyNHB4JyxcbiAgICB3aWR0aDogJzI0cHgnLFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6ICcyNHB4JyxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogJzI0cHgnLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6ICcyNHB4JyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogJzI0cHgnLFxuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgYmFja2dyb3VuZENvbG9yOiAkZGlzYWJsZWQgPyAkdGhlbWUuY29sb3JzLnNsaWRlckhhbmRsZUZpbGxEaXNhYmxlZCA6ICR0aGVtZS5jb2xvcnMuc2xpZGVySGFuZGxlRmlsbCxcbiAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgYm94U2hhZG93OiBwcm9wcy4kaXNGb2N1c1Zpc2libGUgPyBcIjAgMCAwIDNweCBcIi5jb25jYXQoJHRoZW1lLmNvbG9ycy5hY2NlbnQpIDogJzAgMXB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMTIpJyxcbiAgICBjdXJzb3I6ICRkaXNhYmxlZCA/ICdub3QtYWxsb3dlZCcgOiAnaW5oZXJpdCdcbiAgfTtcbn0pO1xuVGh1bWIuZGlzcGxheU5hbWUgPSBcIlRodW1iXCI7XG5UaHVtYi5kaXNwbGF5TmFtZSA9ICdTdHlsZWRUaHVtYic7XG5leHBvcnQgdmFyIElubmVyVGh1bWIgPSBzdHlsZWQoJ2RpdicsIGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgJGRpc2FibGVkID0gcHJvcHMuJGRpc2FibGVkLFxuICAgICAgJHRoZW1lID0gcHJvcHMuJHRoZW1lO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJy0xNnB4JyxcbiAgICB3aWR0aDogJzRweCcsXG4gICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAkZGlzYWJsZWQgPyAkdGhlbWUuY29sb3JzLnNsaWRlckhhbmRsZUZpbGxEaXNhYmxlZCA6ICR0aGVtZS5jb2xvcnMuc2xpZGVySGFuZGxlSW5uZXJGaWxsXG4gIH07XG59KTtcbklubmVyVGh1bWIuZGlzcGxheU5hbWUgPSBcIklubmVyVGh1bWJcIjtcbklubmVyVGh1bWIuZGlzcGxheU5hbWUgPSAnU3R5bGVkSW5uZXJUaHVtYic7XG5leHBvcnQgdmFyIFRodW1iVmFsdWUgPSBzdHlsZWQoJ2RpdicsIGZ1bmN0aW9uIChwcm9wcykge1xuICB2YXIgJGRpc2FibGVkID0gcHJvcHMuJGRpc2FibGVkLFxuICAgICAgJHRoZW1lID0gcHJvcHMuJHRoZW1lO1xuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IFwiLVwiLmNvbmNhdCgkdGhlbWUuc2l6aW5nLnNjYWxlMTQwMClcbiAgfSwgJHRoZW1lLnR5cG9ncmFwaHkuZm9udDIwMCksIHt9LCB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAkZGlzYWJsZWQgPyAkdGhlbWUuY29sb3JzLnNsaWRlckhhbmRsZUZpbGxEaXNhYmxlZCA6ICR0aGVtZS5jb2xvcnMuc2xpZGVySGFuZGxlSW5uZXJGaWxsLFxuICAgIGNvbG9yOiAkdGhlbWUuY29sb3JzLmNvbnRlbnRJbnZlcnNlUHJpbWFyeSxcbiAgICBwYWRkaW5nTGVmdDogJHRoZW1lLnNpemluZy5zY2FsZTYwMCxcbiAgICBwYWRkaW5nUmlnaHQ6ICR0aGVtZS5zaXppbmcuc2NhbGU2MDAsXG4gICAgcGFkZGluZ1RvcDogJHRoZW1lLnNpemluZy5zY2FsZTUwMCxcbiAgICBwYWRkaW5nQm90dG9tOiAkdGhlbWUuc2l6aW5nLnNjYWxlNTAwLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6ICc0OHB4JyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogJzQ4cHgnLFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6ICc0OHB4JyxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogJzQ4cHgnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gIH0pO1xufSk7XG5UaHVtYlZhbHVlLmRpc3BsYXlOYW1lID0gXCJUaHVtYlZhbHVlXCI7XG5UaHVtYlZhbHVlLmRpc3BsYXlOYW1lID0gJ1N0eWxlZFRodW1iVmFsdWUnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/baseui/esm/slider/styled-components.js\n");

/***/ }),

/***/ "./node_modules/baseui/node_modules/react-range/lib/Range.js":
/*!*******************************************************************!*\
  !*** ./node_modules/baseui/node_modules/react-range/lib/Range.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar React = __importStar(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/baseui/node_modules/react-range/lib/utils.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/baseui/node_modules/react-range/lib/types.js\");\nvar INCREASE_KEYS = ['ArrowRight', 'ArrowUp', 'k', 'PageUp'];\nvar DECREASE_KEYS = ['ArrowLeft', 'ArrowDown', 'j', 'PageDown'];\nvar Range = /** @class */ (function (_super) {\n    __extends(Range, _super);\n    function Range(props) {\n        var _this = _super.call(this, props) || this;\n        _this.trackRef = React.createRef();\n        _this.thumbRefs = [];\n        _this.markRefs = [];\n        _this.state = {\n            draggedTrackPos: [-1, -1],\n            draggedThumbIndex: -1,\n            thumbZIndexes: new Array(_this.props.values.length).fill(0).map(function (t, i) { return i; }),\n            isChanged: false,\n            markOffsets: []\n        };\n        _this.getOffsets = function () {\n            var _a = _this.props, direction = _a.direction, values = _a.values, min = _a.min, max = _a.max;\n            var trackElement = _this.trackRef.current;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackPadding = utils_1.getPaddingAndBorder(trackElement);\n            return _this.getThumbs().map(function (thumb, index) {\n                var thumbOffsets = { x: 0, y: 0 };\n                var thumbRect = thumb.getBoundingClientRect();\n                var thumbMargins = utils_1.getMargin(thumb);\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        thumbOffsets.x = (thumbMargins.left + trackPadding.left) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width * utils_1.relativeValue(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Left:\n                        thumbOffsets.x = (thumbMargins.right + trackPadding.right) * -1;\n                        thumbOffsets.y =\n                            ((thumbRect.height - trackRect.height) / 2 + trackPadding.top) * -1;\n                        thumbOffsets.x +=\n                            trackRect.width -\n                                trackRect.width * utils_1.relativeValue(values[index], min, max) -\n                                thumbRect.width / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Up:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height -\n                                trackRect.height * utils_1.relativeValue(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    case types_1.Direction.Down:\n                        thumbOffsets.x =\n                            ((thumbRect.width - trackRect.width) / 2 +\n                                thumbMargins.left +\n                                trackPadding.left) *\n                                -1;\n                        thumbOffsets.y = -trackPadding.left;\n                        thumbOffsets.y +=\n                            trackRect.height * utils_1.relativeValue(values[index], min, max) -\n                                thumbRect.height / 2;\n                        return thumbOffsets;\n                    default:\n                        return utils_1.assertUnreachable(direction);\n                }\n            });\n        };\n        _this.getThumbs = function () {\n            if (_this.trackRef && _this.trackRef.current) {\n                return Array.from(_this.trackRef.current.children).filter(function (el) {\n                    return el.hasAttribute('aria-valuenow');\n                });\n            }\n            console.warn('No thumbs found in the track container. Did you forget to pass & spread the `props` param in renderTrack?');\n            return [];\n        };\n        _this.getTargetIndex = function (e) {\n            return _this.getThumbs().findIndex(function (child) { return child === e.target || child.contains(e.target); });\n        };\n        _this.addTouchEvents = function (e) {\n            document.addEventListener('touchmove', _this.schdOnTouchMove, {\n                passive: false\n            });\n            document.addEventListener('touchend', _this.schdOnEnd, {\n                passive: false\n            });\n            document.addEventListener('touchcancel', _this.schdOnEnd, {\n                passive: false\n            });\n        };\n        _this.addMouseEvents = function (e) {\n            document.addEventListener('mousemove', _this.schdOnMouseMove);\n            document.addEventListener('mouseup', _this.schdOnEnd);\n        };\n        _this.onMouseDownTrack = function (e) {\n            var _a;\n            if (e.button !== 0)\n                return;\n            e.persist();\n            e.preventDefault();\n            _this.addMouseEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.clientX, e.clientY]\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) { return t.current; }), e.clientX, e.clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function () { return _this.onMove(e.clientX, e.clientY); });\n            }\n        };\n        _this.onResize = function () {\n            utils_1.translateThumbs(_this.getThumbs(), _this.getOffsets(), _this.props.rtl);\n            _this.calculateMarkOffsets();\n        };\n        _this.onTouchStartTrack = function (e) {\n            var _a;\n            e.persist();\n            _this.addTouchEvents(e.nativeEvent);\n            if (_this.props.values.length > 1 && _this.props.draggableTrack) {\n                if (_this.thumbRefs.some(function (thumbRef) { var _a; return (_a = thumbRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target); }))\n                    return;\n                // handle dragging the whole track\n                _this.setState({\n                    draggedTrackPos: [e.touches[0].clientX, e.touches[0].clientY]\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n            else {\n                // get the index of the thumb that is closest to the place where the track is clicked\n                var draggedThumbIndex = utils_1.getClosestThumbIndex(_this.thumbRefs.map(function (t) { return t.current; }), e.touches[0].clientX, e.touches[0].clientY, _this.props.direction);\n                // move the thumb which is closest to the place where the track is clicked\n                (_a = _this.thumbRefs[draggedThumbIndex].current) === null || _a === void 0 ? void 0 : _a.focus();\n                _this.setState({\n                    draggedThumbIndex: draggedThumbIndex\n                }, function () { return _this.onMove(e.touches[0].clientX, e.touches[0].clientY); });\n            }\n        };\n        _this.onMouseOrTouchStart = function (e) {\n            if (_this.props.disabled)\n                return;\n            var isTouch = utils_1.isTouchEvent(e);\n            if (!isTouch && e.button !== 0)\n                return;\n            var index = _this.getTargetIndex(e);\n            if (index === -1)\n                return;\n            if (isTouch) {\n                _this.addTouchEvents(e);\n            }\n            else {\n                _this.addMouseEvents(e);\n            }\n            _this.setState({\n                draggedThumbIndex: index,\n                thumbZIndexes: _this.state.thumbZIndexes.map(function (t, i) {\n                    if (i === index) {\n                        return Math.max.apply(Math, _this.state.thumbZIndexes);\n                    }\n                    return t <= _this.state.thumbZIndexes[index] ? t : t - 1;\n                })\n            });\n        };\n        _this.onMouseMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.clientX, e.clientY);\n        };\n        _this.onTouchMove = function (e) {\n            e.preventDefault();\n            _this.onMove(e.touches[0].clientX, e.touches[0].clientY);\n        };\n        _this.onKeyDown = function (e) {\n            var _a = _this.props, values = _a.values, onChange = _a.onChange, step = _a.step, rtl = _a.rtl, direction = _a.direction;\n            var isChanged = _this.state.isChanged;\n            var index = _this.getTargetIndex(e.nativeEvent);\n            var inverter = rtl || direction === types_1.Direction.Left || direction === types_1.Direction.Down\n                ? -1\n                : 1;\n            if (index === -1)\n                return;\n            if (INCREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] + inverter * (e.key === 'PageUp' ? step * 10 : step), index)));\n            }\n            else if (DECREASE_KEYS.includes(e.key)) {\n                e.preventDefault();\n                _this.setState({\n                    draggedThumbIndex: index,\n                    isChanged: true\n                });\n                onChange(utils_1.replaceAt(values, index, _this.normalizeValue(values[index] -\n                    inverter * (e.key === 'PageDown' ? step * 10 : step), index)));\n            }\n            else if (e.key === 'Tab') {\n                _this.setState({ draggedThumbIndex: -1 }, function () {\n                    // If key pressed when thumb was moving, fire onFinalChange\n                    if (isChanged) {\n                        _this.fireOnFinalChange();\n                    }\n                });\n            }\n            else {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            }\n        };\n        _this.onKeyUp = function (e) {\n            var isChanged = _this.state.isChanged;\n            _this.setState({\n                draggedThumbIndex: -1\n            }, function () {\n                if (isChanged) {\n                    _this.fireOnFinalChange();\n                }\n            });\n        };\n        _this.onMove = function (clientX, clientY) {\n            var _a = _this.state, draggedThumbIndex = _a.draggedThumbIndex, draggedTrackPos = _a.draggedTrackPos;\n            var _b = _this.props, direction = _b.direction, min = _b.min, max = _b.max, onChange = _b.onChange, values = _b.values, step = _b.step, rtl = _b.rtl;\n            if (draggedThumbIndex === -1 &&\n                draggedTrackPos[0] === -1 &&\n                draggedTrackPos[1] === -1)\n                return null;\n            var trackElement = _this.trackRef.current;\n            // If component was closed down prematurely, A last onMove could be triggered based on requestAnimationFrame()\n            if (!trackElement)\n                return null;\n            var trackRect = trackElement.getBoundingClientRect();\n            var trackLength = utils_1.isVertical(direction)\n                ? trackRect.height\n                : trackRect.width;\n            if (draggedTrackPos[0] !== -1 && draggedTrackPos[1] !== -1) {\n                // calculate how much it moved since the last update\n                var dX = clientX - draggedTrackPos[0];\n                var dY = clientY - draggedTrackPos[1];\n                // calculate the delta of the value\n                var deltaValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                    case types_1.Direction.Left:\n                        deltaValue = (dX / trackLength) * (max - min);\n                        break;\n                    case types_1.Direction.Down:\n                    case types_1.Direction.Up:\n                        deltaValue = (dY / trackLength) * (max - min);\n                        break;\n                    default:\n                        utils_1.assertUnreachable(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    deltaValue *= -1;\n                }\n                if (Math.abs(deltaValue) >= step / 2) {\n                    // adjust delta so it fits into the range\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        if ((values[i] === max && Math.sign(deltaValue) === 1) ||\n                            (values[i] === min && Math.sign(deltaValue) === -1))\n                            return;\n                        var thumbValue = values[i] + deltaValue;\n                        if (thumbValue > max)\n                            deltaValue = max - values[i];\n                        else if (thumbValue < min)\n                            deltaValue = min - values[i];\n                    }\n                    // add the delta to each thumb\n                    var newValues = values.slice(0);\n                    for (var i = 0; i < _this.thumbRefs.length; i++) {\n                        newValues = utils_1.replaceAt(newValues, i, _this.normalizeValue(values[i] + deltaValue, i));\n                    }\n                    _this.setState({\n                        draggedTrackPos: [clientX, clientY]\n                    });\n                    onChange(newValues);\n                }\n            }\n            else {\n                var newValue = 0;\n                switch (direction) {\n                    case types_1.Direction.Right:\n                        newValue =\n                            ((clientX - trackRect.left) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Left:\n                        newValue =\n                            ((trackLength - (clientX - trackRect.left)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    case types_1.Direction.Down:\n                        newValue =\n                            ((clientY - trackRect.top) / trackLength) * (max - min) + min;\n                        break;\n                    case types_1.Direction.Up:\n                        newValue =\n                            ((trackLength - (clientY - trackRect.top)) / trackLength) *\n                                (max - min) +\n                                min;\n                        break;\n                    default:\n                        utils_1.assertUnreachable(direction);\n                }\n                // invert for RTL\n                if (rtl) {\n                    newValue = max + min - newValue;\n                }\n                if (Math.abs(values[draggedThumbIndex] - newValue) >= step / 2) {\n                    onChange(utils_1.replaceAt(values, draggedThumbIndex, _this.normalizeValue(newValue, draggedThumbIndex)));\n                }\n            }\n        };\n        _this.normalizeValue = function (value, index) {\n            var _a = _this.props, min = _a.min, max = _a.max, step = _a.step, allowOverlap = _a.allowOverlap, values = _a.values;\n            return utils_1.normalizeValue(value, index, min, max, step, allowOverlap, values);\n        };\n        _this.onEnd = function (e) {\n            e.preventDefault();\n            document.removeEventListener('mousemove', _this.schdOnMouseMove);\n            document.removeEventListener('touchmove', _this.schdOnTouchMove);\n            document.removeEventListener('mouseup', _this.schdOnEnd);\n            document.removeEventListener('touchend', _this.schdOnEnd);\n            document.removeEventListener('touchcancel', _this.schdOnEnd);\n            if (_this.state.draggedThumbIndex === -1 &&\n                _this.state.draggedTrackPos[0] === -1 &&\n                _this.state.draggedTrackPos[1] === -1)\n                return null;\n            _this.setState({ draggedThumbIndex: -1, draggedTrackPos: [-1, -1] }, function () {\n                _this.fireOnFinalChange();\n            });\n        };\n        _this.fireOnFinalChange = function () {\n            _this.setState({ isChanged: false });\n            var _a = _this.props, onFinalChange = _a.onFinalChange, values = _a.values;\n            if (onFinalChange) {\n                onFinalChange(values);\n            }\n        };\n        _this.calculateMarkOffsets = function () {\n            if (!_this.props.renderMark ||\n                !_this.trackRef ||\n                _this.trackRef.current === null)\n                return;\n            var elStyles = window.getComputedStyle(_this.trackRef.current);\n            var trackWidth = parseInt(elStyles.width, 10);\n            var trackHeight = parseInt(elStyles.height, 10);\n            var paddingLeft = parseInt(elStyles.paddingLeft, 10);\n            var paddingTop = parseInt(elStyles.paddingTop, 10);\n            var res = [];\n            for (var i = 0; i < _this.numOfMarks + 1; i++) {\n                var markHeight = 9999;\n                var markWidth = 9999;\n                if (_this.markRefs[i].current) {\n                    var markRect = _this.markRefs[i].current.getBoundingClientRect();\n                    markHeight = markRect.height;\n                    markWidth = markRect.width;\n                }\n                if (_this.props.direction === types_1.Direction.Left ||\n                    _this.props.direction === types_1.Direction.Right) {\n                    res.push([\n                        Math.round((trackWidth / _this.numOfMarks) * i + paddingLeft - markWidth / 2),\n                        -Math.round((markHeight - trackHeight) / 2)\n                    ]);\n                }\n                else {\n                    res.push([\n                        Math.round((trackHeight / _this.numOfMarks) * i + paddingTop - markHeight / 2),\n                        -Math.round((markWidth - trackWidth) / 2)\n                    ]);\n                }\n            }\n            _this.setState({ markOffsets: res });\n        };\n        if (props.step === 0) {\n            throw new Error('\"step\" property should be a positive number');\n        }\n        _this.numOfMarks = (props.max - props.min) / _this.props.step;\n        _this.schdOnMouseMove = utils_1.schd(_this.onMouseMove);\n        _this.schdOnTouchMove = utils_1.schd(_this.onTouchMove);\n        _this.schdOnEnd = utils_1.schd(_this.onEnd);\n        _this.thumbRefs = props.values.map(function () { return React.createRef(); });\n        for (var i = 0; i < _this.numOfMarks + 1; i++) {\n            _this.markRefs[i] = React.createRef();\n        }\n        return _this;\n    }\n    Range.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, values = _a.values, min = _a.min, step = _a.step;\n        this.resizeObserver = window.ResizeObserver\n            ? new window.ResizeObserver(this.onResize)\n            : {\n                observe: function () { return window.addEventListener('resize', _this.onResize); },\n                unobserve: function () { return window.removeEventListener('resize', _this.onResize); }\n            };\n        document.addEventListener('touchstart', this.onMouseOrTouchStart, {\n            passive: false\n        });\n        document.addEventListener('mousedown', this.onMouseOrTouchStart, {\n            passive: false\n        });\n        !this.props.allowOverlap && utils_1.checkInitialOverlap(this.props.values);\n        this.props.values.forEach(function (value) {\n            return utils_1.checkBoundaries(value, _this.props.min, _this.props.max);\n        });\n        this.resizeObserver.observe(this.trackRef.current);\n        utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), this.props.rtl);\n        this.calculateMarkOffsets();\n        values.forEach(function (value) {\n            if (!utils_1.isStepDivisible(min, value, step)) {\n                console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');\n            }\n        });\n    };\n    Range.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a = this.props, max = _a.max, min = _a.min, step = _a.step, values = _a.values, rtl = _a.rtl;\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step) {\n            this.markRefs = [];\n            this.numOfMarks = (max - min) / step;\n            for (var i = 0; i < this.numOfMarks + 1; i++) {\n                this.markRefs[i] = React.createRef();\n            }\n        }\n        utils_1.translateThumbs(this.getThumbs(), this.getOffsets(), rtl);\n        // ensure offsets are calculated when the refs for the marks have been created\n        // and those refs have been mounted to the dom\n        // on the state update in calculateOffsets with new markOffsets are calculated\n        if (prevProps.max !== max ||\n            prevProps.min !== min ||\n            prevProps.step !== step ||\n            prevState.markOffsets.length !== this.state.markOffsets.length) {\n            this.calculateMarkOffsets();\n            values.forEach(function (value) {\n                if (!utils_1.isStepDivisible(min, value, step)) {\n                    console.warn('The `values` property is in conflict with the current `step`, `min`, and `max` properties. Please provide values that are accessible using the min, max, and step values.');\n                }\n            });\n        }\n    };\n    Range.prototype.componentWillUnmount = function () {\n        var options = {\n            passive: false\n        };\n        document.removeEventListener('mousedown', this.onMouseOrTouchStart, options);\n        // These need to be removed!!\n        document.removeEventListener('mousemove', this.schdOnMouseMove);\n        document.removeEventListener('touchmove', this.schdOnTouchMove);\n        document.removeEventListener('touchstart', this.onMouseOrTouchStart);\n        document.removeEventListener('mouseup', this.schdOnEnd);\n        document.removeEventListener('touchend', this.schdOnEnd);\n        this.resizeObserver.unobserve(this.trackRef.current);\n    };\n    Range.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, renderTrack = _a.renderTrack, renderThumb = _a.renderThumb, _b = _a.renderMark, renderMark = _b === void 0 ? function () { return null; } : _b, values = _a.values, min = _a.min, max = _a.max, allowOverlap = _a.allowOverlap, disabled = _a.disabled;\n        var _c = this.state, draggedThumbIndex = _c.draggedThumbIndex, thumbZIndexes = _c.thumbZIndexes, markOffsets = _c.markOffsets;\n        return renderTrack({\n            props: {\n                style: {\n                    // creates stacking context that prevents z-index applied to thumbs\n                    // interfere with other elements\n                    transform: 'scale(1)',\n                    cursor: draggedThumbIndex > -1\n                        ? 'grabbing'\n                        : this.props.draggableTrack\n                            ? utils_1.isVertical(this.props.direction)\n                                ? 'ns-resize'\n                                : 'ew-resize'\n                            : values.length === 1 && !disabled\n                                ? 'pointer'\n                                : 'inherit'\n                },\n                onMouseDown: disabled ? utils_1.voidFn : this.onMouseDownTrack,\n                onTouchStart: disabled ? utils_1.voidFn : this.onTouchStartTrack,\n                ref: this.trackRef\n            },\n            isDragged: this.state.draggedThumbIndex > -1,\n            disabled: disabled,\n            children: __spreadArrays(markOffsets.map(function (offset, index, arr) {\n                return renderMark({\n                    props: {\n                        style: _this.props.direction === types_1.Direction.Left ||\n                            _this.props.direction === types_1.Direction.Right\n                            ? {\n                                position: 'absolute',\n                                left: offset[0] + \"px\",\n                                marginTop: offset[1] + \"px\"\n                            }\n                            : {\n                                position: 'absolute',\n                                top: offset[0] + \"px\",\n                                marginLeft: offset[1] + \"px\"\n                            },\n                        key: \"mark\" + index,\n                        ref: _this.markRefs[index]\n                    },\n                    index: index\n                });\n            }), values.map(function (value, index) {\n                var isDragged = _this.state.draggedThumbIndex === index;\n                return renderThumb({\n                    index: index,\n                    value: value,\n                    isDragged: isDragged,\n                    props: {\n                        style: {\n                            position: 'absolute',\n                            zIndex: thumbZIndexes[index],\n                            cursor: disabled ? 'inherit' : isDragged ? 'grabbing' : 'grab',\n                            userSelect: 'none',\n                            touchAction: 'none',\n                            WebkitUserSelect: 'none',\n                            MozUserSelect: 'none',\n                            msUserSelect: 'none'\n                        },\n                        key: index,\n                        tabIndex: disabled ? undefined : 0,\n                        'aria-valuemax': allowOverlap ? max : values[index + 1] || max,\n                        'aria-valuemin': allowOverlap ? min : values[index - 1] || min,\n                        'aria-valuenow': value,\n                        draggable: false,\n                        ref: _this.thumbRefs[index],\n                        role: 'slider',\n                        onKeyDown: disabled ? utils_1.voidFn : _this.onKeyDown,\n                        onKeyUp: disabled ? utils_1.voidFn : _this.onKeyUp\n                    }\n                });\n            }))\n        });\n    };\n    Range.defaultProps = {\n        step: 1,\n        direction: types_1.Direction.Right,\n        rtl: false,\n        disabled: false,\n        allowOverlap: false,\n        draggableTrack: false,\n        min: 0,\n        max: 100\n    };\n    return Range;\n}(React.Component));\nexports[\"default\"] = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvUmFuZ2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxtQ0FBbUMsb0NBQW9DLGdCQUFnQjtBQUN2RixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLG1CQUFPLENBQUMsNENBQU87QUFDeEMsY0FBYyxtQkFBTyxDQUFDLDRFQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw0RUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsV0FBVztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHdEQUF3RDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsUUFBUSw0RkFBNEY7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLDRDQUE0QztBQUM3RTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csbUJBQW1CO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQiw0Q0FBNEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxRQUFRLDRGQUE0RjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0Isa0VBQWtFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxtQkFBbUI7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLGtFQUFrRTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFrRDtBQUMvRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDJCQUEyQjtBQUNwRix3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJEQUEyRDtBQUNsRyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0osZUFBZTtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2V1aS9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL1JhbmdlLmpzPzBjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgSU5DUkVBU0VfS0VZUyA9IFsnQXJyb3dSaWdodCcsICdBcnJvd1VwJywgJ2snLCAnUGFnZVVwJ107XG52YXIgREVDUkVBU0VfS0VZUyA9IFsnQXJyb3dMZWZ0JywgJ0Fycm93RG93bicsICdqJywgJ1BhZ2VEb3duJ107XG52YXIgUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhbmdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhbmdlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFja1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy50aHVtYlJlZnMgPSBbXTtcbiAgICAgICAgX3RoaXMubWFya1JlZnMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFstMSwgLTFdLFxuICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IC0xLFxuICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogbmV3IEFycmF5KF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGgpLmZpbGwoMCkubWFwKGZ1bmN0aW9uICh0LCBpKSB7IHJldHVybiBpOyB9KSxcbiAgICAgICAgICAgIGlzQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICBtYXJrT2Zmc2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkaXJlY3Rpb24gPSBfYS5kaXJlY3Rpb24sIHZhbHVlcyA9IF9hLnZhbHVlcywgbWluID0gX2EubWluLCBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gX3RoaXMudHJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciB0cmFja1JlY3QgPSB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tQYWRkaW5nID0gdXRpbHNfMS5nZXRQYWRkaW5nQW5kQm9yZGVyKHRyYWNrRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0VGh1bWJzKCkubWFwKGZ1bmN0aW9uICh0aHVtYiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJPZmZzZXRzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICAgICAgdmFyIHRodW1iUmVjdCA9IHRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0aHVtYk1hcmdpbnMgPSB1dGlsc18xLmdldE1hcmdpbih0aHVtYik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ID0gKHRodW1iTWFyZ2lucy5sZWZ0ICsgdHJhY2tQYWRkaW5nLmxlZnQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueCA9ICh0aHVtYk1hcmdpbnMucmlnaHQgKyB0cmFja1BhZGRpbmcucmlnaHQpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCh0aHVtYlJlY3QuaGVpZ2h0IC0gdHJhY2tSZWN0LmhlaWdodCkgLyAyICsgdHJhY2tQYWRkaW5nLnRvcCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iT2Zmc2V0cy54ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZWN0LndpZHRoICogdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LndpZHRoIC0gdHJhY2tSZWN0LndpZHRoKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk1hcmdpbnMubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUGFkZGluZy5sZWZ0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPSAtdHJhY2tQYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlY3QuaGVpZ2h0ICogdXRpbHNfMS5yZWxhdGl2ZVZhbHVlKHZhbHVlc1tpbmRleF0sIG1pbiwgbWF4KSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRodW1iT2Zmc2V0cztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodGh1bWJSZWN0LndpZHRoIC0gdHJhY2tSZWN0LndpZHRoKSAvIDIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk1hcmdpbnMubGVmdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUGFkZGluZy5sZWZ0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJPZmZzZXRzLnkgPSAtdHJhY2tQYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYk9mZnNldHMueSArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVjdC5oZWlnaHQgKiB1dGlsc18xLnJlbGF0aXZlVmFsdWUodmFsdWVzW2luZGV4XSwgbWluLCBtYXgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGh1bWJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGh1bWJPZmZzZXRzO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGh1bWJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyYWNrUmVmICYmIF90aGlzLnRyYWNrUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShfdGhpcy50cmFja1JlZi5jdXJyZW50LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gdGh1bWJzIGZvdW5kIGluIHRoZSB0cmFjayBjb250YWluZXIuIERpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgJiBzcHJlYWQgdGhlIGBwcm9wc2AgcGFyYW0gaW4gcmVuZGVyVHJhY2s/Jyk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRhcmdldEluZGV4ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRUaHVtYnMoKS5maW5kSW5kZXgoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZCA9PT0gZS50YXJnZXQgfHwgY2hpbGQuY29udGFpbnMoZS50YXJnZXQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlLCB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfdGhpcy5zY2hkT25FbmQsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIF90aGlzLnNjaGRPbkVuZCwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuYWRkTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX3RoaXMuc2NoZE9uTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlRG93blRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLmFkZE1vdXNlRXZlbnRzKGUubmF0aXZlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlcy5sZW5ndGggPiAxICYmIF90aGlzLnByb3BzLmRyYWdnYWJsZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRodW1iUmVmcy5zb21lKGZ1bmN0aW9uICh0aHVtYlJlZikgeyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aHVtYlJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZS50YXJnZXQpOyB9KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBkcmFnZ2luZyB0aGUgd2hvbGUgdHJhY2tcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1BvczogW2UuY2xpZW50WCwgZS5jbGllbnRZXVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgdGh1bWIgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIHZhciBkcmFnZ2VkVGh1bWJJbmRleCA9IHV0aWxzXzEuZ2V0Q2xvc2VzdFRodW1iSW5kZXgoX3RoaXMudGh1bWJSZWZzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5jdXJyZW50OyB9KSwgZS5jbGllbnRYLCBlLmNsaWVudFksIF90aGlzLnByb3BzLmRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgdGh1bWIgd2hpY2ggaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy50aHVtYlJlZnNbZHJhZ2dlZFRodW1iSW5kZXhdLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGRyYWdnZWRUaHVtYkluZGV4XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnMoX3RoaXMuZ2V0VGh1bWJzKCksIF90aGlzLmdldE9mZnNldHMoKSwgX3RoaXMucHJvcHMucnRsKTtcbiAgICAgICAgICAgIF90aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uVG91Y2hTdGFydFRyYWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZS5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMudmFsdWVzLmxlbmd0aCA+IDEgJiYgX3RoaXMucHJvcHMuZHJhZ2dhYmxlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGh1bWJSZWZzLnNvbWUoZnVuY3Rpb24gKHRodW1iUmVmKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRodW1iUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlLnRhcmdldCk7IH0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRyYWdnaW5nIHRoZSB3aG9sZSB0cmFja1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRyYWNrUG9zOiBbZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZXVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcGxhY2Ugd2hlcmUgdGhlIHRyYWNrIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ2dlZFRodW1iSW5kZXggPSB1dGlsc18xLmdldENsb3Nlc3RUaHVtYkluZGV4KF90aGlzLnRodW1iUmVmcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuY3VycmVudDsgfSksIGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSwgX3RoaXMucHJvcHMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSB0aHVtYiB3aGljaCBpcyBjbG9zZXN0IHRvIHRoZSBwbGFjZSB3aGVyZSB0aGUgdHJhY2sgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIChfYSA9IF90aGlzLnRodW1iUmVmc1tkcmFnZ2VkVGh1bWJJbmRleF0uY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogZHJhZ2dlZFRodW1iSW5kZXhcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW91c2VPclRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc1RvdWNoID0gdXRpbHNfMS5pc1RvdWNoRXZlbnQoZSk7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2ggJiYgZS5idXR0b24gIT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3RoaXMuZ2V0VGFyZ2V0SW5kZXgoZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkVG91Y2hFdmVudHMoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRNb3VzZUV2ZW50cyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdGh1bWJaSW5kZXhlczogX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcy5tYXAoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQgPD0gX3RoaXMuc3RhdGUudGh1bWJaSW5kZXhlc1tpbmRleF0gPyB0IDogdCAtIDE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5vbk1vdmUoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5vbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25LZXlEb3duID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIHN0ZXAgPSBfYS5zdGVwLCBydGwgPSBfYS5ydGwsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBfdGhpcy5zdGF0ZS5pc0NoYW5nZWQ7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5nZXRUYXJnZXRJbmRleChlLm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICAgIHZhciBpbnZlcnRlciA9IHJ0bCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQgfHwgZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5Eb3duXG4gICAgICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKElOQ1JFQVNFX0tFWVMuaW5jbHVkZXMoZS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZFRodW1iSW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0NoYW5nZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZSh1dGlsc18xLnJlcGxhY2VBdCh2YWx1ZXMsIGluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZSh2YWx1ZXNbaW5kZXhdICsgaW52ZXJ0ZXIgKiAoZS5rZXkgPT09ICdQYWdlVXAnID8gc3RlcCAqIDEwIDogc3RlcCksIGluZGV4KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoREVDUkVBU0VfS0VZUy5pbmNsdWRlcyhlLmtleSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVGh1bWJJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKHV0aWxzXzEucmVwbGFjZUF0KHZhbHVlcywgaW5kZXgsIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpbmRleF0gLVxuICAgICAgICAgICAgICAgICAgICBpbnZlcnRlciAqIChlLmtleSA9PT0gJ1BhZ2VEb3duJyA/IHN0ZXAgKiAxMCA6IHN0ZXApLCBpbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZHJhZ2dlZFRodW1iSW5kZXg6IC0xIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5IHByZXNzZWQgd2hlbiB0aHVtYiB3YXMgbW92aW5nLCBmaXJlIG9uRmluYWxDaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlT25GaW5hbENoYW5nZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25LZXlVcCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgaXNDaGFuZ2VkID0gX3RoaXMuc3RhdGUuaXNDaGFuZ2VkO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRUaHVtYkluZGV4OiAtMVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb3ZlID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlLCBkcmFnZ2VkVGh1bWJJbmRleCA9IF9hLmRyYWdnZWRUaHVtYkluZGV4LCBkcmFnZ2VkVHJhY2tQb3MgPSBfYS5kcmFnZ2VkVHJhY2tQb3M7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGlyZWN0aW9uID0gX2IuZGlyZWN0aW9uLCBtaW4gPSBfYi5taW4sIG1heCA9IF9iLm1heCwgb25DaGFuZ2UgPSBfYi5vbkNoYW5nZSwgdmFsdWVzID0gX2IudmFsdWVzLCBzdGVwID0gX2Iuc3RlcCwgcnRsID0gX2IucnRsO1xuICAgICAgICAgICAgaWYgKGRyYWdnZWRUaHVtYkluZGV4ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGRyYWdnZWRUcmFja1Bvc1swXSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3NbMV0gPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHRyYWNrRWxlbWVudCA9IF90aGlzLnRyYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBJZiBjb21wb25lbnQgd2FzIGNsb3NlZCBkb3duIHByZW1hdHVyZWx5LCBBIGxhc3Qgb25Nb3ZlIGNvdWxkIGJlIHRyaWdnZXJlZCBiYXNlZCBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuICAgICAgICAgICAgaWYgKCF0cmFja0VsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdHJhY2tSZWN0ID0gdHJhY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gdXRpbHNfMS5pc1ZlcnRpY2FsKGRpcmVjdGlvbilcbiAgICAgICAgICAgICAgICA/IHRyYWNrUmVjdC5oZWlnaHRcbiAgICAgICAgICAgICAgICA6IHRyYWNrUmVjdC53aWR0aDtcbiAgICAgICAgICAgIGlmIChkcmFnZ2VkVHJhY2tQb3NbMF0gIT09IC0xICYmIGRyYWdnZWRUcmFja1Bvc1sxXSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggaXQgbW92ZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgICAgICAgICAgICAgdmFyIGRYID0gY2xpZW50WCAtIGRyYWdnZWRUcmFja1Bvc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZFkgPSBjbGllbnRZIC0gZHJhZ2dlZFRyYWNrUG9zWzFdO1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgb2YgdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSAoZFggLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVZhbHVlID0gKGRZIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuYXNzZXJ0VW5yZWFjaGFibGUoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW52ZXJ0IGZvciBSVExcbiAgICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgKj0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YVZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgZGVsdGEgc28gaXQgZml0cyBpbnRvIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLnRodW1iUmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZXNbaV0gPT09IG1heCAmJiBNYXRoLnNpZ24oZGVsdGFWYWx1ZSkgPT09IDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlc1tpXSA9PT0gbWluICYmIE1hdGguc2lnbihkZWx0YVZhbHVlKSA9PT0gLTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aHVtYlZhbHVlID0gdmFsdWVzW2ldICsgZGVsdGFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHVtYlZhbHVlID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtYXggLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aHVtYlZhbHVlIDwgbWluKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVmFsdWUgPSBtaW4gLSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZWx0YSB0byBlYWNoIHRodW1iXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMudGh1bWJSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXMgPSB1dGlsc18xLnJlcGxhY2VBdChuZXdWYWx1ZXMsIGksIF90aGlzLm5vcm1hbGl6ZVZhbHVlKHZhbHVlc1tpXSArIGRlbHRhVmFsdWUsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2VkVHJhY2tQb3M6IFtjbGllbnRYLCBjbGllbnRZXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRYIC0gdHJhY2tSZWN0LmxlZnQpIC8gdHJhY2tMZW5ndGgpICogKG1heCAtIG1pbikgKyBtaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WCAtIHRyYWNrUmVjdC5sZWZ0KSkgLyB0cmFja0xlbmd0aCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4IC0gbWluKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChjbGllbnRZIC0gdHJhY2tSZWN0LnRvcCkgLyB0cmFja0xlbmd0aCkgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHR5cGVzXzEuRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgodHJhY2tMZW5ndGggLSAoY2xpZW50WSAtIHRyYWNrUmVjdC50b3ApKSAvIHRyYWNrTGVuZ3RoKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXggLSBtaW4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLmFzc2VydFVucmVhY2hhYmxlKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGludmVydCBmb3IgUlRMXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG1heCArIG1pbiAtIG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsdWVzW2RyYWdnZWRUaHVtYkluZGV4XSAtIG5ld1ZhbHVlKSA+PSBzdGVwIC8gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSh1dGlsc18xLnJlcGxhY2VBdCh2YWx1ZXMsIGRyYWdnZWRUaHVtYkluZGV4LCBfdGhpcy5ub3JtYWxpemVWYWx1ZShuZXdWYWx1ZSwgZHJhZ2dlZFRodW1iSW5kZXgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5ub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgc3RlcCA9IF9hLnN0ZXAsIGFsbG93T3ZlcmxhcCA9IF9hLmFsbG93T3ZlcmxhcCwgdmFsdWVzID0gX2EudmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzXzEubm9ybWFsaXplVmFsdWUodmFsdWUsIGluZGV4LCBtaW4sIG1heCwgc3RlcCwgYWxsb3dPdmVybGFwLCB2YWx1ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5zY2hkT25Nb3VzZU1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBfdGhpcy5zY2hkT25FbmQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmRyYWdnZWRUaHVtYkluZGV4ID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmRyYWdnZWRUcmFja1Bvc1swXSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5kcmFnZ2VkVHJhY2tQb3NbMV0gPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBkcmFnZ2VkVGh1bWJJbmRleDogLTEsIGRyYWdnZWRUcmFja1BvczogWy0xLCAtMV0gfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcmVPbkZpbmFsQ2hhbmdlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZmlyZU9uRmluYWxDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzQ2hhbmdlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgb25GaW5hbENoYW5nZSA9IF9hLm9uRmluYWxDaGFuZ2UsIHZhbHVlcyA9IF9hLnZhbHVlcztcbiAgICAgICAgICAgIGlmIChvbkZpbmFsQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgb25GaW5hbENoYW5nZSh2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMucmVuZGVyTWFyayB8fFxuICAgICAgICAgICAgICAgICFfdGhpcy50cmFja1JlZiB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrUmVmLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGVsU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoX3RoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tXaWR0aCA9IHBhcnNlSW50KGVsU3R5bGVzLndpZHRoLCAxMCk7XG4gICAgICAgICAgICB2YXIgdHJhY2tIZWlnaHQgPSBwYXJzZUludChlbFN0eWxlcy5oZWlnaHQsIDEwKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdMZWZ0LCAxMCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlSW50KGVsU3R5bGVzLnBhZGRpbmdUb3AsIDEwKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrSGVpZ2h0ID0gOTk5OTtcbiAgICAgICAgICAgICAgICB2YXIgbWFya1dpZHRoID0gOTk5OTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubWFya1JlZnNbaV0uY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFya1JlY3QgPSBfdGhpcy5tYXJrUmVmc1tpXS5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrSGVpZ2h0ID0gbWFya1JlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBtYXJrV2lkdGggPSBtYXJrUmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHRyYWNrV2lkdGggLyBfdGhpcy5udW1PZk1hcmtzKSAqIGkgKyBwYWRkaW5nTGVmdCAtIG1hcmtXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLU1hdGgucm91bmQoKG1hcmtIZWlnaHQgLSB0cmFja0hlaWdodCkgLyAyKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHRyYWNrSGVpZ2h0IC8gX3RoaXMubnVtT2ZNYXJrcykgKiBpICsgcGFkZGluZ1RvcCAtIG1hcmtIZWlnaHQgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1NYXRoLnJvdW5kKChtYXJrV2lkdGggLSB0cmFja1dpZHRoKSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgbWFya09mZnNldHM6IHJlcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3BzLnN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzdGVwXCIgcHJvcGVydHkgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubnVtT2ZNYXJrcyA9IChwcm9wcy5tYXggLSBwcm9wcy5taW4pIC8gX3RoaXMucHJvcHMuc3RlcDtcbiAgICAgICAgX3RoaXMuc2NoZE9uTW91c2VNb3ZlID0gdXRpbHNfMS5zY2hkKF90aGlzLm9uTW91c2VNb3ZlKTtcbiAgICAgICAgX3RoaXMuc2NoZE9uVG91Y2hNb3ZlID0gdXRpbHNfMS5zY2hkKF90aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICAgICAgX3RoaXMuc2NoZE9uRW5kID0gdXRpbHNfMS5zY2hkKF90aGlzLm9uRW5kKTtcbiAgICAgICAgX3RoaXMudGh1bWJSZWZzID0gcHJvcHMudmFsdWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBSZWFjdC5jcmVhdGVSZWYoKTsgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtT2ZNYXJrcyArIDE7IGkrKykge1xuICAgICAgICAgICAgX3RoaXMubWFya1JlZnNbaV0gPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmFsdWVzID0gX2EudmFsdWVzLCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gd2luZG93LlJlc2l6ZU9ic2VydmVyXG4gICAgICAgICAgICA/IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5vblJlc2l6ZSlcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG9ic2VydmU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfdGhpcy5vblJlc2l6ZSk7IH0sXG4gICAgICAgICAgICAgICAgdW5vYnNlcnZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgX3RoaXMub25SZXNpemUpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0LCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgIXRoaXMucHJvcHMuYWxsb3dPdmVybGFwICYmIHV0aWxzXzEuY2hlY2tJbml0aWFsT3ZlcmxhcCh0aGlzLnByb3BzLnZhbHVlcyk7XG4gICAgICAgIHRoaXMucHJvcHMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS5jaGVja0JvdW5kYXJpZXModmFsdWUsIF90aGlzLnByb3BzLm1pbiwgX3RoaXMucHJvcHMubWF4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnRyYWNrUmVmLmN1cnJlbnQpO1xuICAgICAgICB1dGlsc18xLnRyYW5zbGF0ZVRodW1icyh0aGlzLmdldFRodW1icygpLCB0aGlzLmdldE9mZnNldHMoKSwgdGhpcy5wcm9wcy5ydGwpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZU1hcmtPZmZzZXRzKCk7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF1dGlsc18xLmlzU3RlcERpdmlzaWJsZShtaW4sIHZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIGB2YWx1ZXNgIHByb3BlcnR5IGlzIGluIGNvbmZsaWN0IHdpdGggdGhlIGN1cnJlbnQgYHN0ZXBgLCBgbWluYCwgYW5kIGBtYXhgIHByb3BlcnRpZXMuIFBsZWFzZSBwcm92aWRlIHZhbHVlcyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHVzaW5nIHRoZSBtaW4sIG1heCwgYW5kIHN0ZXAgdmFsdWVzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbWF4ID0gX2EubWF4LCBtaW4gPSBfYS5taW4sIHN0ZXAgPSBfYS5zdGVwLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIHJ0bCA9IF9hLnJ0bDtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5tYXggIT09IG1heCB8fFxuICAgICAgICAgICAgcHJldlByb3BzLm1pbiAhPT0gbWluIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMuc3RlcCAhPT0gc3RlcCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrUmVmcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5udW1PZk1hcmtzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bU9mTWFya3MgKyAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtSZWZzW2ldID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHNfMS50cmFuc2xhdGVUaHVtYnModGhpcy5nZXRUaHVtYnMoKSwgdGhpcy5nZXRPZmZzZXRzKCksIHJ0bCk7XG4gICAgICAgIC8vIGVuc3VyZSBvZmZzZXRzIGFyZSBjYWxjdWxhdGVkIHdoZW4gdGhlIHJlZnMgZm9yIHRoZSBtYXJrcyBoYXZlIGJlZW4gY3JlYXRlZFxuICAgICAgICAvLyBhbmQgdGhvc2UgcmVmcyBoYXZlIGJlZW4gbW91bnRlZCB0byB0aGUgZG9tXG4gICAgICAgIC8vIG9uIHRoZSBzdGF0ZSB1cGRhdGUgaW4gY2FsY3VsYXRlT2Zmc2V0cyB3aXRoIG5ldyBtYXJrT2Zmc2V0cyBhcmUgY2FsY3VsYXRlZFxuICAgICAgICBpZiAocHJldlByb3BzLm1heCAhPT0gbWF4IHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubWluICE9PSBtaW4gfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5zdGVwICE9PSBzdGVwIHx8XG4gICAgICAgICAgICBwcmV2U3RhdGUubWFya09mZnNldHMubGVuZ3RoICE9PSB0aGlzLnN0YXRlLm1hcmtPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVNYXJrT2Zmc2V0cygpO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsc18xLmlzU3RlcERpdmlzaWJsZShtaW4sIHZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsdWVzYCBwcm9wZXJ0eSBpcyBpbiBjb25mbGljdCB3aXRoIHRoZSBjdXJyZW50IGBzdGVwYCwgYG1pbmAsIGFuZCBgbWF4YCBwcm9wZXJ0aWVzLiBQbGVhc2UgcHJvdmlkZSB2YWx1ZXMgdGhhdCBhcmUgYWNjZXNzaWJsZSB1c2luZyB0aGUgbWluLCBtYXgsIGFuZCBzdGVwIHZhbHVlcy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFuZ2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZU9yVG91Y2hTdGFydCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIFRoZXNlIG5lZWQgdG8gYmUgcmVtb3ZlZCEhXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuc2NoZE9uTW91c2VNb3ZlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5zY2hkT25Ub3VjaE1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlT3JUb3VjaFN0YXJ0KTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuc2NoZE9uRW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnNjaGRPbkVuZCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMudHJhY2tSZWYuY3VycmVudCk7XG4gICAgfTtcbiAgICBSYW5nZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCByZW5kZXJUcmFjayA9IF9hLnJlbmRlclRyYWNrLCByZW5kZXJUaHVtYiA9IF9hLnJlbmRlclRodW1iLCBfYiA9IF9hLnJlbmRlck1hcmssIHJlbmRlck1hcmsgPSBfYiA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSA6IF9iLCB2YWx1ZXMgPSBfYS52YWx1ZXMsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBhbGxvd092ZXJsYXAgPSBfYS5hbGxvd092ZXJsYXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQ7XG4gICAgICAgIHZhciBfYyA9IHRoaXMuc3RhdGUsIGRyYWdnZWRUaHVtYkluZGV4ID0gX2MuZHJhZ2dlZFRodW1iSW5kZXgsIHRodW1iWkluZGV4ZXMgPSBfYy50aHVtYlpJbmRleGVzLCBtYXJrT2Zmc2V0cyA9IF9jLm1hcmtPZmZzZXRzO1xuICAgICAgICByZXR1cm4gcmVuZGVyVHJhY2soe1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIHN0YWNraW5nIGNvbnRleHQgdGhhdCBwcmV2ZW50cyB6LWluZGV4IGFwcGxpZWQgdG8gdGh1bWJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyZmVyZSB3aXRoIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJyxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBkcmFnZ2VkVGh1bWJJbmRleCA+IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdncmFiYmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5kcmFnZ2FibGVUcmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXRpbHNfMS5pc1ZlcnRpY2FsKHRoaXMucHJvcHMuZGlyZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICducy1yZXNpemUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2V3LXJlc2l6ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlcy5sZW5ndGggPT09IDEgJiYgIWRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2luaGVyaXQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbk1vdXNlRG93bjogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IHRoaXMub25Nb3VzZURvd25UcmFjayxcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnQ6IGRpc2FibGVkID8gdXRpbHNfMS52b2lkRm4gOiB0aGlzLm9uVG91Y2hTdGFydFRyYWNrLFxuICAgICAgICAgICAgICAgIHJlZjogdGhpcy50cmFja1JlZlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzRHJhZ2dlZDogdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA+IC0xLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgY2hpbGRyZW46IF9fc3ByZWFkQXJyYXlzKG1hcmtPZmZzZXRzLm1hcChmdW5jdGlvbiAob2Zmc2V0LCBpbmRleCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1hcmsoe1xuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gdHlwZXNfMS5EaXJlY3Rpb24uUmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldFswXSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBvZmZzZXRbMV0gKyBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldFswXSArIFwicHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0WzFdICsgXCJweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJtYXJrXCIgKyBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogX3RoaXMubWFya1JlZnNbaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSksIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RyYWdnZWQgPSBfdGhpcy5zdGF0ZS5kcmFnZ2VkVGh1bWJJbmRleCA9PT0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRodW1iKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dlZDogaXNEcmFnZ2VkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IHRodW1iWkluZGV4ZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogZGlzYWJsZWQgPyAnaW5oZXJpdCcgOiBpc0RyYWdnZWQgPyAnZ3JhYmJpbmcnIDogJ2dyYWInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3pVc2VyU2VsZWN0OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNVc2VyU2VsZWN0OiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXg6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWF4JzogYWxsb3dPdmVybGFwID8gbWF4IDogdmFsdWVzW2luZGV4ICsgMV0gfHwgbWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiBhbGxvd092ZXJsYXAgPyBtaW4gOiB2YWx1ZXNbaW5kZXggLSAxXSB8fCBtaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW5vdyc6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogX3RoaXMudGh1bWJSZWZzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdzbGlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBkaXNhYmxlZCA/IHV0aWxzXzEudm9pZEZuIDogX3RoaXMub25LZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25LZXlVcDogZGlzYWJsZWQgPyB1dGlsc18xLnZvaWRGbiA6IF90aGlzLm9uS2V5VXBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmFuZ2UuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBzdGVwOiAxLFxuICAgICAgICBkaXJlY3Rpb246IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0LFxuICAgICAgICBydGw6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gICAgICAgIGRyYWdnYWJsZVRyYWNrOiBmYWxzZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJhbmdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/baseui/node_modules/react-range/lib/Range.js\n");

/***/ }),

/***/ "./node_modules/baseui/node_modules/react-range/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/baseui/node_modules/react-range/lib/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkValuesAgainstBoundaries = exports.relativeValue = exports.useThumbOverlap = exports.Direction = exports.getTrackBackground = exports.Range = void 0;\nvar Range_1 = __importDefault(__webpack_require__(/*! ./Range */ \"./node_modules/baseui/node_modules/react-range/lib/Range.js\"));\nexports.Range = Range_1.default;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/baseui/node_modules/react-range/lib/utils.js\");\nObject.defineProperty(exports, \"getTrackBackground\", ({ enumerable: true, get: function () { return utils_1.getTrackBackground; } }));\nObject.defineProperty(exports, \"useThumbOverlap\", ({ enumerable: true, get: function () { return utils_1.useThumbOverlap; } }));\nObject.defineProperty(exports, \"relativeValue\", ({ enumerable: true, get: function () { return utils_1.relativeValue; } }));\nObject.defineProperty(exports, \"checkValuesAgainstBoundaries\", ({ enumerable: true, get: function () { return utils_1.checkValuesAgainstBoundaries; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/baseui/node_modules/react-range/lib/types.js\");\nObject.defineProperty(exports, \"Direction\", ({ enumerable: true, get: function () { return types_1.Direction; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyxhQUFhO0FBQ3ZKLDhCQUE4QixtQkFBTyxDQUFDLDRFQUFTO0FBQy9DLGFBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsNEVBQVM7QUFDL0Isc0RBQXFELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQ25JLG1EQUFrRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM3SCxpREFBZ0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDekgsZ0VBQStELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFDO0FBQ3ZKLGNBQWMsbUJBQU8sQ0FBQyw0RUFBUztBQUMvQiw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2V1aS9ub2RlX21vZHVsZXMvcmVhY3QtcmFuZ2UvbGliL2luZGV4LmpzP2VmMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXMgPSBleHBvcnRzLnJlbGF0aXZlVmFsdWUgPSBleHBvcnRzLnVzZVRodW1iT3ZlcmxhcCA9IGV4cG9ydHMuRGlyZWN0aW9uID0gZXhwb3J0cy5nZXRUcmFja0JhY2tncm91bmQgPSBleHBvcnRzLlJhbmdlID0gdm9pZCAwO1xudmFyIFJhbmdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUmFuZ2VcIikpO1xuZXhwb3J0cy5SYW5nZSA9IFJhbmdlXzEuZGVmYXVsdDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRUcmFja0JhY2tncm91bmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2V0VHJhY2tCYWNrZ3JvdW5kOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXNlVGh1bWJPdmVybGFwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnVzZVRodW1iT3ZlcmxhcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbGF0aXZlVmFsdWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucmVsYXRpdmVWYWx1ZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllczsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXJlY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuRGlyZWN0aW9uOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/baseui/node_modules/react-range/lib/index.js\n");

/***/ }),

/***/ "./node_modules/baseui/node_modules/react-range/lib/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/baseui/node_modules/react-range/lib/types.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Direction = void 0;\nvar Direction;\n(function (Direction) {\n    Direction[\"Right\"] = \"to right\";\n    Direction[\"Left\"] = \"to left\";\n    Direction[\"Down\"] = \"to bottom\";\n    Direction[\"Up\"] = \"to top\";\n})(Direction = exports.Direction || (exports.Direction = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdHlwZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DLGlCQUFpQixLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNldWkvbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlL2xpYi90eXBlcy5qcz82MTJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXJlY3Rpb24gPSB2b2lkIDA7XG52YXIgRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICBEaXJlY3Rpb25bXCJSaWdodFwiXSA9IFwidG8gcmlnaHRcIjtcbiAgICBEaXJlY3Rpb25bXCJMZWZ0XCJdID0gXCJ0byBsZWZ0XCI7XG4gICAgRGlyZWN0aW9uW1wiRG93blwiXSA9IFwidG8gYm90dG9tXCI7XG4gICAgRGlyZWN0aW9uW1wiVXBcIl0gPSBcInRvIHRvcFwiO1xufSkoRGlyZWN0aW9uID0gZXhwb3J0cy5EaXJlY3Rpb24gfHwgKGV4cG9ydHMuRGlyZWN0aW9uID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/baseui/node_modules/react-range/lib/types.js\n");

/***/ }),

/***/ "./node_modules/baseui/node_modules/react-range/lib/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/baseui/node_modules/react-range/lib/utils.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useThumbOverlap = exports.assertUnreachable = exports.voidFn = exports.getTrackBackground = exports.replaceAt = exports.schd = exports.translate = exports.getClosestThumbIndex = exports.translateThumbs = exports.getPaddingAndBorder = exports.getMargin = exports.checkInitialOverlap = exports.checkValuesAgainstBoundaries = exports.checkBoundaries = exports.isVertical = exports.relativeValue = exports.normalizeValue = exports.isStepDivisible = exports.isTouchEvent = exports.getStepDecimals = void 0;\nvar react_1 = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/baseui/node_modules/react-range/lib/types.js\");\nvar getStepDecimals = function (step) {\n    var decimals = step.toString().split('.')[1];\n    return decimals ? decimals.length : 0;\n};\nexports.getStepDecimals = getStepDecimals;\nfunction isTouchEvent(event) {\n    return ((event.touches && event.touches.length) ||\n        (event.changedTouches && event.changedTouches.length));\n}\nexports.isTouchEvent = isTouchEvent;\nfunction isStepDivisible(min, max, step) {\n    var res = (max - min) / step;\n    var precision = 8;\n    var roundedRes = Number(res.toFixed(precision));\n    return parseInt(roundedRes.toString(), 10) === roundedRes;\n}\nexports.isStepDivisible = isStepDivisible;\nfunction normalizeValue(value, index, min, max, step, allowOverlap, values) {\n    var BIG_NUM = 10e10;\n    value = Math.round(value * BIG_NUM) / BIG_NUM;\n    if (!allowOverlap) {\n        var prev = values[index - 1];\n        var next = values[index + 1];\n        if (prev && prev > value)\n            return prev;\n        if (next && next < value)\n            return next;\n    }\n    if (value > max)\n        return max;\n    if (value < min)\n        return min;\n    // `remainder` is a difference between the given value and a full step value\n    // that is closest lower to the given value and is in the range between the min value\n    // and the given value\n    var remainder = Math.floor(value * BIG_NUM - min * BIG_NUM) %\n        Math.floor(step * BIG_NUM);\n    var closestLowerNum = Math.floor(value * BIG_NUM - Math.abs(remainder));\n    var rounded = remainder === 0 ? value : closestLowerNum / BIG_NUM;\n    // Values with a remainder `< step/2` are rounded to the closest lower value\n    // while values with a remainder `= > step/2` are rounded to the closest bigger value\n    var res = Math.abs(remainder / BIG_NUM) < step / 2\n        ? rounded\n        : rounded + step;\n    var decimalPlaces = exports.getStepDecimals(step);\n    return parseFloat(res.toFixed(decimalPlaces));\n}\nexports.normalizeValue = normalizeValue;\nfunction relativeValue(value, min, max) {\n    return (value - min) / (max - min);\n}\nexports.relativeValue = relativeValue;\nfunction isVertical(direction) {\n    return direction === types_1.Direction.Up || direction === types_1.Direction.Down;\n}\nexports.isVertical = isVertical;\nfunction checkBoundaries(value, min, max) {\n    if (min >= max) {\n        throw new RangeError(\"min (\" + min + \") is equal/bigger than max (\" + max + \")\");\n    }\n    if (value < min) {\n        throw new RangeError(\"value (\" + value + \") is smaller than min (\" + min + \")\");\n    }\n    if (value > max) {\n        throw new RangeError(\"value (\" + value + \") is bigger than max (\" + max + \")\");\n    }\n}\nexports.checkBoundaries = checkBoundaries;\nfunction checkValuesAgainstBoundaries(value, min, max) {\n    if (value < min) {\n        // set selectedValue to min\n        return min;\n    }\n    if (value > max) {\n        // set selectedValue to max\n        return max;\n    }\n    else {\n        return value;\n    }\n}\nexports.checkValuesAgainstBoundaries = checkValuesAgainstBoundaries;\nfunction checkInitialOverlap(values) {\n    if (values.length < 2)\n        return;\n    if (!values.slice(1).every(function (item, i) { return values[i] <= item; })) {\n        throw new RangeError(\"values={[\" + values + \"]} needs to be sorted when allowOverlap={false}\");\n    }\n}\nexports.checkInitialOverlap = checkInitialOverlap;\nfunction getMargin(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['margin-top'], 10),\n        bottom: parseInt(style['margin-bottom'], 10),\n        left: parseInt(style['margin-left'], 10),\n        right: parseInt(style['margin-right'], 10)\n    };\n}\nexports.getMargin = getMargin;\nfunction getPaddingAndBorder(element) {\n    var style = window.getComputedStyle(element);\n    return {\n        top: parseInt(style['padding-top'], 10) + parseInt(style['border-top-width'], 10),\n        bottom: parseInt(style['padding-bottom'], 10) + parseInt(style['border-bottom-width'], 10),\n        left: parseInt(style['padding-left'], 10) + parseInt(style['border-left-width'], 10),\n        right: parseInt(style['padding-right'], 10) + parseInt(style['border-right-width'], 10),\n    };\n}\nexports.getPaddingAndBorder = getPaddingAndBorder;\nfunction translateThumbs(elements, offsets, rtl) {\n    var inverter = rtl ? -1 : 1;\n    elements.forEach(function (element, index) {\n        return translate(element, inverter * offsets[index].x, offsets[index].y);\n    });\n}\nexports.translateThumbs = translateThumbs;\n/**\n * Util function for calculating the index of the thumb that is closes to a given position\n * @param thumbs - array of Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getClosestThumbIndex(thumbs, clientX, clientY, direction) {\n    var thumbIndex = 0;\n    var minThumbDistance = getThumbDistance(thumbs[0], clientX, clientY, direction);\n    for (var i = 1; i < thumbs.length; i++) {\n        var thumbDistance = getThumbDistance(thumbs[i], clientX, clientY, direction);\n        if (thumbDistance < minThumbDistance) {\n            minThumbDistance = thumbDistance;\n            thumbIndex = i;\n        }\n    }\n    return thumbIndex;\n}\nexports.getClosestThumbIndex = getClosestThumbIndex;\nfunction translate(element, x, y) {\n    element.style.transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n}\nexports.translate = translate;\n// adapted from https://github.com/alexreardon/raf-schd\nvar schd = function (fn) {\n    var lastArgs = [];\n    var frameId = null;\n    var wrapperFn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        lastArgs = args;\n        if (frameId) {\n            return;\n        }\n        frameId = requestAnimationFrame(function () {\n            frameId = null;\n            fn.apply(void 0, lastArgs);\n        });\n    };\n    return wrapperFn;\n};\nexports.schd = schd;\nfunction replaceAt(values, index, value) {\n    var ret = values.slice(0);\n    ret[index] = value;\n    return ret;\n}\nexports.replaceAt = replaceAt;\nfunction getTrackBackground(_a) {\n    var values = _a.values, colors = _a.colors, min = _a.min, max = _a.max, _b = _a.direction, direction = _b === void 0 ? types_1.Direction.Right : _b, _c = _a.rtl, rtl = _c === void 0 ? false : _c;\n    if (rtl && direction === types_1.Direction.Right) {\n        direction = types_1.Direction.Left;\n    }\n    else if (rtl && types_1.Direction.Left) {\n        direction = types_1.Direction.Right;\n    }\n    // sort values ascending\n    var progress = values.slice(0).sort(function (a, b) { return a - b; }).map(function (value) { return ((value - min) / (max - min)) * 100; });\n    var middle = progress.reduce(function (acc, point, index) {\n        return acc + \", \" + colors[index] + \" \" + point + \"%, \" + colors[index + 1] + \" \" + point + \"%\";\n    }, '');\n    return \"linear-gradient(\" + direction + \", \" + colors[0] + \" 0%\" + middle + \", \" + colors[colors.length - 1] + \" 100%)\";\n}\nexports.getTrackBackground = getTrackBackground;\nfunction voidFn() { }\nexports.voidFn = voidFn;\nfunction assertUnreachable(x) {\n    throw new Error(\"Didn't expect to get here\");\n}\nexports.assertUnreachable = assertUnreachable;\n/**\n * Util function for grabbing the true largest width of a thumb\n * including the label\n * @param thumbEl - Thumb element to grab the largest width from\n * @param value - Thumb value, not label value\n * @param separator - Label separator value\n */\nvar getThumbWidth = function (thumbEl, value, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var width = Math.ceil(__spreadArrays([thumbEl], Array.from(thumbEl.children)).reduce(function (width, el) {\n        var elWidth = Math.ceil(el.getBoundingClientRect().width);\n        /**\n         * If a label contains a merged label value, it won't return the true\n         * label width for that Thumb. Clone the label and change the value\n         * to that individual Thumb value in order to grab the true width.\n         */\n        if (el.innerText &&\n            el.innerText.includes(separator) &&\n            el.childElementCount === 0) {\n            var elClone = el.cloneNode(true);\n            elClone.innerHTML = valueToLabel(value.toFixed(decimalPlaces));\n            elClone.style.visibility = 'hidden';\n            document.body.appendChild(elClone);\n            elWidth = Math.ceil(elClone.getBoundingClientRect().width);\n            document.body.removeChild(elClone);\n        }\n        return elWidth > width ? elWidth : width;\n    }, thumbEl.getBoundingClientRect().width));\n    return width;\n};\n/**\n * Bulk of logic for thumb overlaps\n * Consider a scenario with 5 thumbs;\n * Thumb 1 overlaps with thumb 0 and thumb 2\n * Thumb 2 overlaps with thumb 3\n * We need an array that contains [0, 1, 2, 3]\n * The function needs to return the directly overlapping thumbs\n * and all thumbs overlapping linked to those and so on\n * @param index - Thumb index calculating overlaps for\n * @param offsets - Current Array of Thumb offsets for Range\n * @param thumbs - Array of Thumb elements\n * @param values - Array of Thumb values\n * @param separator - String separator for merged label values\n * @returns overlaps - Array of all overlapping thumbs from the index\n */\nvar getOverlaps = function (index, offsets, thumbs, values, separator, decimalPlaces, valueToLabel) {\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var overlaps = [];\n    /**\n     * Recursive function for building the overlaps Array\n     * If an overlap is found, find the overlaps for that overlap\n     * @param thumbIndex current Thumb index to find overlaps from\n     */\n    var buildOverlaps = function (thumbIndex) {\n        var thumbXWidth = getThumbWidth(thumbs[thumbIndex], values[thumbIndex], separator, decimalPlaces, valueToLabel);\n        var thumbX = offsets[thumbIndex].x;\n        /**\n         * Iterate through the Thumb offsets, if there is a match\n         * add the thumbIndex and siblingIndex to the overlaps Array\n         *\n         * Then build overlaps from the overlapping siblingIndex\n         */\n        offsets.forEach(function (_a, siblingIndex) {\n            var siblingX = _a.x;\n            var siblingWidth = getThumbWidth(thumbs[siblingIndex], values[siblingIndex], separator, decimalPlaces, valueToLabel);\n            if (thumbIndex !== siblingIndex &&\n                ((thumbX >= siblingX && thumbX <= siblingX + siblingWidth) ||\n                    (thumbX + thumbXWidth >= siblingX &&\n                        thumbX + thumbXWidth <= siblingX + siblingWidth))) {\n                if (!overlaps.includes(siblingIndex)) {\n                    overlaps.push(thumbIndex);\n                    overlaps.push(siblingIndex);\n                    overlaps = __spreadArrays(overlaps, [thumbIndex, siblingIndex]);\n                    buildOverlaps(siblingIndex);\n                }\n            }\n        });\n    };\n    buildOverlaps(index);\n    // Sort and remove duplicates from the built overlaps\n    return Array.from(new Set(overlaps.sort()));\n};\n/**\n * A custom React Hook for calculating whether a thumb overlaps\n * another and whether labels could/should merge.\n * @param rangeRef - React ref value of Range component\n * @param values - current Range values Array\n * @param index - thumb index\n * @param step - step value, used to calculate the number of decimal places\n * @param separator - string to separate thumb values\n * @returns label value + styling for thumb label\n */\nvar useThumbOverlap = function (rangeRef, values, index, step, separator, valueToLabel) {\n    if (step === void 0) { step = 0.1; }\n    if (separator === void 0) { separator = ' - '; }\n    if (valueToLabel === void 0) { valueToLabel = function (value) { return value; }; }\n    var decimalPlaces = exports.getStepDecimals(step);\n    // Create initial label style and value. Label value defaults to thumb value\n    var _a = react_1.useState({}), labelStyle = _a[0], setLabelStyle = _a[1];\n    var _b = react_1.useState(valueToLabel(values[index].toFixed(decimalPlaces))), labelValue = _b[0], setLabelValue = _b[1];\n    // When the rangeRef or values change, update the Thumb label values and styling\n    react_1.useEffect(function () {\n        if (rangeRef) {\n            var thumbs = rangeRef.getThumbs();\n            if (thumbs.length < 1)\n                return;\n            var newStyle = {};\n            var offsets_1 = rangeRef.getOffsets();\n            /**\n             * Get any overlaps for the given Thumb index. This must return all linked\n             * Thumbs. So if there are 4 Thumbs and Thumbs 2, 3 and 4 overlap. If we are\n             * getting the overlaps for Thumb 1 and it overlaps only Thumb 2, we must get\n             * 2, 3 and 4 also.\n             */\n            var overlaps = getOverlaps(index, offsets_1, thumbs, values, separator, decimalPlaces, valueToLabel);\n            // Set a default label value of the Thumb value\n            var labelValue_1 = valueToLabel(values[index].toFixed(decimalPlaces));\n            /**\n             * If there are overlaps for the Thumb, we need to calculate the correct\n             * Label value along with the relevant styling. We only want to show a Label\n             * for the left most Thumb in an overlapping set.\n             * All other Thumbs will be set to display: none.\n             */\n            if (overlaps.length) {\n                /**\n                 * Get an Array of the offsets for the overlapping Thumbs\n                 * This is so we can determine if the Thumb we are looking at\n                 * is the left most thumb in an overlapping set\n                 */\n                var offsetsX = overlaps.reduce(function (a, c, i, s) {\n                    return a.length ? __spreadArrays(a, [offsets_1[s[i]].x]) : [offsets_1[s[i]].x];\n                }, []);\n                /**\n                 * If our Thumb is the left most Thumb, we can build a Label value\n                 * and set the style for that Label\n                 */\n                if (Math.min.apply(Math, offsetsX) === offsets_1[index].x) {\n                    /**\n                     * First calculate the Label value. To do this,\n                     * grab all the values for the Thumbs in our overlaps.\n                     * Then convert that to a Set and sort it whilst removing duplicates.\n                     */\n                    var labelValues_1 = [];\n                    overlaps.forEach(function (thumb) {\n                        labelValues_1.push(values[thumb].toFixed(decimalPlaces));\n                    });\n                    /**\n                     *  Update the labelValue with the resulting Array\n                     *  joined by our defined separator\n                     */\n                    labelValue_1 = Array.from(new Set(labelValues_1.sort(function (a, b) { return parseFloat(a) - parseFloat(b); })))\n                        .map(valueToLabel)\n                        .join(separator);\n                    /**\n                     * Lastly, build the label styling. The label styling will\n                     * position the label and apply a transform so that it's centered.\n                     * We want the center point between the left edge of the left most Thumb\n                     * and the right edge of the right most Thumb.\n                     */\n                    var first = Math.min.apply(Math, offsetsX);\n                    var last = Math.max.apply(Math, offsetsX);\n                    var lastWidth = thumbs[overlaps[offsetsX.indexOf(last)]].getBoundingClientRect().width;\n                    newStyle.left = Math.abs(first - (last + lastWidth)) / 2 + \"px\";\n                    newStyle.transform = 'translate(-50%, 0)';\n                }\n                else {\n                    // If the Thumb isn't the left most Thumb, hide the Label!\n                    newStyle.visibility = 'hidden';\n                }\n            }\n            // Update the label value and style\n            setLabelValue(labelValue_1);\n            setLabelStyle(newStyle);\n        }\n    }, [rangeRef, values]);\n    return [labelValue, labelStyle];\n};\nexports.useThumbOverlap = useThumbOverlap;\n/**\n * Util function for calculating the distance of the center of a thumb\n * form a given mouse/touch target's position\n * @param thumbEl - Thumb element to calculate the distance from\n * @param clientX - target x position (mouse/touch)\n * @param clientY - target y position (mouse/touch)\n * @param direction - the direction of the track\n */\nfunction getThumbDistance(thumbEl, clientX, clientY, direction) {\n    var _a = thumbEl.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n    return isVertical(direction) ? Math.abs(clientY - (top + height / 2)) : Math.abs(clientX - (left + width / 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZXVpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtEQUFrRCxRQUFRO0FBQzFELHlDQUF5QyxRQUFRO0FBQ2pELHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGlCQUFpQixHQUFHLDRCQUE0QixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLGlCQUFpQixHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixHQUFHLHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QjtBQUNuZixjQUFjLG1CQUFPLENBQUMsNENBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLDRFQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwyQkFBMkI7QUFDL0Usc0NBQXNDLGtCQUFrQixzQ0FBc0MsTUFBTTtBQUNwRztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxlQUFlLHlCQUF5Qiw2Q0FBNkM7QUFDL0k7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUMsa0NBQWtDO0FBQ3JFO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRix1Q0FBdUM7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZXVpL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS9saWIvdXRpbHMuanM/MjkzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VUaHVtYk92ZXJsYXAgPSBleHBvcnRzLmFzc2VydFVucmVhY2hhYmxlID0gZXhwb3J0cy52b2lkRm4gPSBleHBvcnRzLmdldFRyYWNrQmFja2dyb3VuZCA9IGV4cG9ydHMucmVwbGFjZUF0ID0gZXhwb3J0cy5zY2hkID0gZXhwb3J0cy50cmFuc2xhdGUgPSBleHBvcnRzLmdldENsb3Nlc3RUaHVtYkluZGV4ID0gZXhwb3J0cy50cmFuc2xhdGVUaHVtYnMgPSBleHBvcnRzLmdldFBhZGRpbmdBbmRCb3JkZXIgPSBleHBvcnRzLmdldE1hcmdpbiA9IGV4cG9ydHMuY2hlY2tJbml0aWFsT3ZlcmxhcCA9IGV4cG9ydHMuY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcyA9IGV4cG9ydHMuY2hlY2tCb3VuZGFyaWVzID0gZXhwb3J0cy5pc1ZlcnRpY2FsID0gZXhwb3J0cy5yZWxhdGl2ZVZhbHVlID0gZXhwb3J0cy5ub3JtYWxpemVWYWx1ZSA9IGV4cG9ydHMuaXNTdGVwRGl2aXNpYmxlID0gZXhwb3J0cy5pc1RvdWNoRXZlbnQgPSBleHBvcnRzLmdldFN0ZXBEZWNpbWFscyA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBnZXRTdGVwRGVjaW1hbHMgPSBmdW5jdGlvbiAoc3RlcCkge1xuICAgIHZhciBkZWNpbWFscyA9IHN0ZXAudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdO1xuICAgIHJldHVybiBkZWNpbWFscyA/IGRlY2ltYWxzLmxlbmd0aCA6IDA7XG59O1xuZXhwb3J0cy5nZXRTdGVwRGVjaW1hbHMgPSBnZXRTdGVwRGVjaW1hbHM7XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gKChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB8fFxuICAgICAgICAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSk7XG59XG5leHBvcnRzLmlzVG91Y2hFdmVudCA9IGlzVG91Y2hFdmVudDtcbmZ1bmN0aW9uIGlzU3RlcERpdmlzaWJsZShtaW4sIG1heCwgc3RlcCkge1xuICAgIHZhciByZXMgPSAobWF4IC0gbWluKSAvIHN0ZXA7XG4gICAgdmFyIHByZWNpc2lvbiA9IDg7XG4gICAgdmFyIHJvdW5kZWRSZXMgPSBOdW1iZXIocmVzLnRvRml4ZWQocHJlY2lzaW9uKSk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJvdW5kZWRSZXMudG9TdHJpbmcoKSwgMTApID09PSByb3VuZGVkUmVzO1xufVxuZXhwb3J0cy5pc1N0ZXBEaXZpc2libGUgPSBpc1N0ZXBEaXZpc2libGU7XG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSwgaW5kZXgsIG1pbiwgbWF4LCBzdGVwLCBhbGxvd092ZXJsYXAsIHZhbHVlcykge1xuICAgIHZhciBCSUdfTlVNID0gMTBlMTA7XG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlICogQklHX05VTSkgLyBCSUdfTlVNO1xuICAgIGlmICghYWxsb3dPdmVybGFwKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdmFsdWVzW2luZGV4IC0gMV07XG4gICAgICAgIHZhciBuZXh0ID0gdmFsdWVzW2luZGV4ICsgMV07XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYgPiB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0IDwgdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIGlmICh2YWx1ZSA8IG1pbilcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAvLyBgcmVtYWluZGVyYCBpcyBhIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZ2l2ZW4gdmFsdWUgYW5kIGEgZnVsbCBzdGVwIHZhbHVlXG4gICAgLy8gdGhhdCBpcyBjbG9zZXN0IGxvd2VyIHRvIHRoZSBnaXZlbiB2YWx1ZSBhbmQgaXMgaW4gdGhlIHJhbmdlIGJldHdlZW4gdGhlIG1pbiB2YWx1ZVxuICAgIC8vIGFuZCB0aGUgZ2l2ZW4gdmFsdWVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5mbG9vcih2YWx1ZSAqIEJJR19OVU0gLSBtaW4gKiBCSUdfTlVNKSAlXG4gICAgICAgIE1hdGguZmxvb3Ioc3RlcCAqIEJJR19OVU0pO1xuICAgIHZhciBjbG9zZXN0TG93ZXJOdW0gPSBNYXRoLmZsb29yKHZhbHVlICogQklHX05VTSAtIE1hdGguYWJzKHJlbWFpbmRlcikpO1xuICAgIHZhciByb3VuZGVkID0gcmVtYWluZGVyID09PSAwID8gdmFsdWUgOiBjbG9zZXN0TG93ZXJOdW0gLyBCSUdfTlVNO1xuICAgIC8vIFZhbHVlcyB3aXRoIGEgcmVtYWluZGVyIGA8IHN0ZXAvMmAgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgbG93ZXIgdmFsdWVcbiAgICAvLyB3aGlsZSB2YWx1ZXMgd2l0aCBhIHJlbWFpbmRlciBgPSA+IHN0ZXAvMmAgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgYmlnZ2VyIHZhbHVlXG4gICAgdmFyIHJlcyA9IE1hdGguYWJzKHJlbWFpbmRlciAvIEJJR19OVU0pIDwgc3RlcCAvIDJcbiAgICAgICAgPyByb3VuZGVkXG4gICAgICAgIDogcm91bmRlZCArIHN0ZXA7XG4gICAgdmFyIGRlY2ltYWxQbGFjZXMgPSBleHBvcnRzLmdldFN0ZXBEZWNpbWFscyhzdGVwKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChyZXMudG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplVmFsdWU7XG5mdW5jdGlvbiByZWxhdGl2ZVZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5leHBvcnRzLnJlbGF0aXZlVmFsdWUgPSByZWxhdGl2ZVZhbHVlO1xuZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSB0eXBlc18xLkRpcmVjdGlvbi5VcCB8fCBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLkRvd247XG59XG5leHBvcnRzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuZnVuY3Rpb24gY2hlY2tCb3VuZGFyaWVzKHZhbHVlLCBtaW4sIG1heCkge1xuICAgIGlmIChtaW4gPj0gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwibWluIChcIiArIG1pbiArIFwiKSBpcyBlcXVhbC9iaWdnZXIgdGhhbiBtYXggKFwiICsgbWF4ICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ2YWx1ZSAoXCIgKyB2YWx1ZSArIFwiKSBpcyBzbWFsbGVyIHRoYW4gbWluIChcIiArIG1pbiArIFwiKVwiKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidmFsdWUgKFwiICsgdmFsdWUgKyBcIikgaXMgYmlnZ2VyIHRoYW4gbWF4IChcIiArIG1heCArIFwiKVwiKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrQm91bmRhcmllcyA9IGNoZWNrQm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrVmFsdWVzQWdhaW5zdEJvdW5kYXJpZXModmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZFZhbHVlIHRvIG1pblxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgLy8gc2V0IHNlbGVjdGVkVmFsdWUgdG8gbWF4XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1ZhbHVlc0FnYWluc3RCb3VuZGFyaWVzID0gY2hlY2tWYWx1ZXNBZ2FpbnN0Qm91bmRhcmllcztcbmZ1bmN0aW9uIGNoZWNrSW5pdGlhbE92ZXJsYXAodmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2YWx1ZXMuc2xpY2UoMSkuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIHZhbHVlc1tpXSA8PSBpdGVtOyB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInZhbHVlcz17W1wiICsgdmFsdWVzICsgXCJdfSBuZWVkcyB0byBiZSBzb3J0ZWQgd2hlbiBhbGxvd092ZXJsYXA9e2ZhbHNlfVwiKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrSW5pdGlhbE92ZXJsYXAgPSBjaGVja0luaXRpYWxPdmVybGFwO1xuZnVuY3Rpb24gZ2V0TWFyZ2luKGVsZW1lbnQpIHtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tdG9wJ10sIDEwKSxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludChzdHlsZVsnbWFyZ2luLWJvdHRvbSddLCAxMCksXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHN0eWxlWydtYXJnaW4tbGVmdCddLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVsnbWFyZ2luLXJpZ2h0J10sIDEwKVxuICAgIH07XG59XG5leHBvcnRzLmdldE1hcmdpbiA9IGdldE1hcmdpbjtcbmZ1bmN0aW9uIGdldFBhZGRpbmdBbmRCb3JkZXIoZWxlbWVudCkge1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQoc3R5bGVbJ3BhZGRpbmctdG9wJ10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItdG9wLXdpZHRoJ10sIDEwKSxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludChzdHlsZVsncGFkZGluZy1ib3R0b20nXSwgMTApICsgcGFyc2VJbnQoc3R5bGVbJ2JvcmRlci1ib3R0b20td2lkdGgnXSwgMTApLFxuICAgICAgICBsZWZ0OiBwYXJzZUludChzdHlsZVsncGFkZGluZy1sZWZ0J10sIDEwKSArIHBhcnNlSW50KHN0eWxlWydib3JkZXItbGVmdC13aWR0aCddLCAxMCksXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludChzdHlsZVsncGFkZGluZy1yaWdodCddLCAxMCkgKyBwYXJzZUludChzdHlsZVsnYm9yZGVyLXJpZ2h0LXdpZHRoJ10sIDEwKSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRQYWRkaW5nQW5kQm9yZGVyID0gZ2V0UGFkZGluZ0FuZEJvcmRlcjtcbmZ1bmN0aW9uIHRyYW5zbGF0ZVRodW1icyhlbGVtZW50cywgb2Zmc2V0cywgcnRsKSB7XG4gICAgdmFyIGludmVydGVyID0gcnRsID8gLTEgOiAxO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGUoZWxlbWVudCwgaW52ZXJ0ZXIgKiBvZmZzZXRzW2luZGV4XS54LCBvZmZzZXRzW2luZGV4XS55KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudHJhbnNsYXRlVGh1bWJzID0gdHJhbnNsYXRlVGh1bWJzO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgaW5kZXggb2YgdGhlIHRodW1iIHRoYXQgaXMgY2xvc2VzIHRvIGEgZ2l2ZW4gcG9zaXRpb25cbiAqIEBwYXJhbSB0aHVtYnMgLSBhcnJheSBvZiBUaHVtYiBlbGVtZW50IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbVxuICogQHBhcmFtIGNsaWVudFggLSB0YXJnZXQgeCBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gY2xpZW50WSAtIHRhcmdldCB5IHBvc2l0aW9uIChtb3VzZS90b3VjaClcbiAqIEBwYXJhbSBkaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmFja1xuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0VGh1bWJJbmRleCh0aHVtYnMsIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbikge1xuICAgIHZhciB0aHVtYkluZGV4ID0gMDtcbiAgICB2YXIgbWluVGh1bWJEaXN0YW5jZSA9IGdldFRodW1iRGlzdGFuY2UodGh1bWJzWzBdLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGh1bWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0aHVtYkRpc3RhbmNlID0gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYnNbaV0sIGNsaWVudFgsIGNsaWVudFksIGRpcmVjdGlvbik7XG4gICAgICAgIGlmICh0aHVtYkRpc3RhbmNlIDwgbWluVGh1bWJEaXN0YW5jZSkge1xuICAgICAgICAgICAgbWluVGh1bWJEaXN0YW5jZSA9IHRodW1iRGlzdGFuY2U7XG4gICAgICAgICAgICB0aHVtYkluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGh1bWJJbmRleDtcbn1cbmV4cG9ydHMuZ2V0Q2xvc2VzdFRodW1iSW5kZXggPSBnZXRDbG9zZXN0VGh1bWJJbmRleDtcbmZ1bmN0aW9uIHRyYW5zbGF0ZShlbGVtZW50LCB4LCB5KSB7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiO1xufVxuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2FsZXhyZWFyZG9uL3JhZi1zY2hkXG52YXIgc2NoZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBsYXN0QXJncyA9IFtdO1xuICAgIHZhciBmcmFtZUlkID0gbnVsbDtcbiAgICB2YXIgd3JhcHBlckZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZyYW1lSWQgPSBudWxsO1xuICAgICAgICAgICAgZm4uYXBwbHkodm9pZCAwLCBsYXN0QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdyYXBwZXJGbjtcbn07XG5leHBvcnRzLnNjaGQgPSBzY2hkO1xuZnVuY3Rpb24gcmVwbGFjZUF0KHZhbHVlcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlcy5zbGljZSgwKTtcbiAgICByZXRbaW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMucmVwbGFjZUF0ID0gcmVwbGFjZUF0O1xuZnVuY3Rpb24gZ2V0VHJhY2tCYWNrZ3JvdW5kKF9hKSB7XG4gICAgdmFyIHZhbHVlcyA9IF9hLnZhbHVlcywgY29sb3JzID0gX2EuY29sb3JzLCBtaW4gPSBfYS5taW4sIG1heCA9IF9hLm1heCwgX2IgPSBfYS5kaXJlY3Rpb24sIGRpcmVjdGlvbiA9IF9iID09PSB2b2lkIDAgPyB0eXBlc18xLkRpcmVjdGlvbi5SaWdodCA6IF9iLCBfYyA9IF9hLnJ0bCwgcnRsID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2M7XG4gICAgaWYgKHJ0bCAmJiBkaXJlY3Rpb24gPT09IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLkxlZnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJ0bCAmJiB0eXBlc18xLkRpcmVjdGlvbi5MZWZ0KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHR5cGVzXzEuRGlyZWN0aW9uLlJpZ2h0O1xuICAgIH1cbiAgICAvLyBzb3J0IHZhbHVlcyBhc2NlbmRpbmdcbiAgICB2YXIgcHJvZ3Jlc3MgPSB2YWx1ZXMuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICgodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbikpICogMTAwOyB9KTtcbiAgICB2YXIgbWlkZGxlID0gcHJvZ3Jlc3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvaW50LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gYWNjICsgXCIsIFwiICsgY29sb3JzW2luZGV4XSArIFwiIFwiICsgcG9pbnQgKyBcIiUsIFwiICsgY29sb3JzW2luZGV4ICsgMV0gKyBcIiBcIiArIHBvaW50ICsgXCIlXCI7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBcImxpbmVhci1ncmFkaWVudChcIiArIGRpcmVjdGlvbiArIFwiLCBcIiArIGNvbG9yc1swXSArIFwiIDAlXCIgKyBtaWRkbGUgKyBcIiwgXCIgKyBjb2xvcnNbY29sb3JzLmxlbmd0aCAtIDFdICsgXCIgMTAwJSlcIjtcbn1cbmV4cG9ydHMuZ2V0VHJhY2tCYWNrZ3JvdW5kID0gZ2V0VHJhY2tCYWNrZ3JvdW5kO1xuZnVuY3Rpb24gdm9pZEZuKCkgeyB9XG5leHBvcnRzLnZvaWRGbiA9IHZvaWRGbjtcbmZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWRuJ3QgZXhwZWN0IHRvIGdldCBoZXJlXCIpO1xufVxuZXhwb3J0cy5hc3NlcnRVbnJlYWNoYWJsZSA9IGFzc2VydFVucmVhY2hhYmxlO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBncmFiYmluZyB0aGUgdHJ1ZSBsYXJnZXN0IHdpZHRoIG9mIGEgdGh1bWJcbiAqIGluY2x1ZGluZyB0aGUgbGFiZWxcbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBncmFiIHRoZSBsYXJnZXN0IHdpZHRoIGZyb21cbiAqIEBwYXJhbSB2YWx1ZSAtIFRodW1iIHZhbHVlLCBub3QgbGFiZWwgdmFsdWVcbiAqIEBwYXJhbSBzZXBhcmF0b3IgLSBMYWJlbCBzZXBhcmF0b3IgdmFsdWVcbiAqL1xudmFyIGdldFRodW1iV2lkdGggPSBmdW5jdGlvbiAodGh1bWJFbCwgdmFsdWUsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKSB7XG4gICAgaWYgKHZhbHVlVG9MYWJlbCA9PT0gdm9pZCAwKSB7IHZhbHVlVG9MYWJlbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07IH1cbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoX19zcHJlYWRBcnJheXMoW3RodW1iRWxdLCBBcnJheS5mcm9tKHRodW1iRWwuY2hpbGRyZW4pKS5yZWR1Y2UoZnVuY3Rpb24gKHdpZHRoLCBlbCkge1xuICAgICAgICB2YXIgZWxXaWR0aCA9IE1hdGguY2VpbChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGxhYmVsIGNvbnRhaW5zIGEgbWVyZ2VkIGxhYmVsIHZhbHVlLCBpdCB3b24ndCByZXR1cm4gdGhlIHRydWVcbiAgICAgICAgICogbGFiZWwgd2lkdGggZm9yIHRoYXQgVGh1bWIuIENsb25lIHRoZSBsYWJlbCBhbmQgY2hhbmdlIHRoZSB2YWx1ZVxuICAgICAgICAgKiB0byB0aGF0IGluZGl2aWR1YWwgVGh1bWIgdmFsdWUgaW4gb3JkZXIgdG8gZ3JhYiB0aGUgdHJ1ZSB3aWR0aC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChlbC5pbm5lclRleHQgJiZcbiAgICAgICAgICAgIGVsLmlubmVyVGV4dC5pbmNsdWRlcyhzZXBhcmF0b3IpICYmXG4gICAgICAgICAgICBlbC5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGVsQ2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBlbENsb25lLmlubmVySFRNTCA9IHZhbHVlVG9MYWJlbCh2YWx1ZS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgIGVsQ2xvbmUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbENsb25lKTtcbiAgICAgICAgICAgIGVsV2lkdGggPSBNYXRoLmNlaWwoZWxDbG9uZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbFdpZHRoID4gd2lkdGggPyBlbFdpZHRoIDogd2lkdGg7XG4gICAgfSwgdGh1bWJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpO1xuICAgIHJldHVybiB3aWR0aDtcbn07XG4vKipcbiAqIEJ1bGsgb2YgbG9naWMgZm9yIHRodW1iIG92ZXJsYXBzXG4gKiBDb25zaWRlciBhIHNjZW5hcmlvIHdpdGggNSB0aHVtYnM7XG4gKiBUaHVtYiAxIG92ZXJsYXBzIHdpdGggdGh1bWIgMCBhbmQgdGh1bWIgMlxuICogVGh1bWIgMiBvdmVybGFwcyB3aXRoIHRodW1iIDNcbiAqIFdlIG5lZWQgYW4gYXJyYXkgdGhhdCBjb250YWlucyBbMCwgMSwgMiwgM11cbiAqIFRoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gdGhlIGRpcmVjdGx5IG92ZXJsYXBwaW5nIHRodW1ic1xuICogYW5kIGFsbCB0aHVtYnMgb3ZlcmxhcHBpbmcgbGlua2VkIHRvIHRob3NlIGFuZCBzbyBvblxuICogQHBhcmFtIGluZGV4IC0gVGh1bWIgaW5kZXggY2FsY3VsYXRpbmcgb3ZlcmxhcHMgZm9yXG4gKiBAcGFyYW0gb2Zmc2V0cyAtIEN1cnJlbnQgQXJyYXkgb2YgVGh1bWIgb2Zmc2V0cyBmb3IgUmFuZ2VcbiAqIEBwYXJhbSB0aHVtYnMgLSBBcnJheSBvZiBUaHVtYiBlbGVtZW50c1xuICogQHBhcmFtIHZhbHVlcyAtIEFycmF5IG9mIFRodW1iIHZhbHVlc1xuICogQHBhcmFtIHNlcGFyYXRvciAtIFN0cmluZyBzZXBhcmF0b3IgZm9yIG1lcmdlZCBsYWJlbCB2YWx1ZXNcbiAqIEByZXR1cm5zIG92ZXJsYXBzIC0gQXJyYXkgb2YgYWxsIG92ZXJsYXBwaW5nIHRodW1icyBmcm9tIHRoZSBpbmRleFxuICovXG52YXIgZ2V0T3ZlcmxhcHMgPSBmdW5jdGlvbiAoaW5kZXgsIG9mZnNldHMsIHRodW1icywgdmFsdWVzLCBzZXBhcmF0b3IsIGRlY2ltYWxQbGFjZXMsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlIGZ1bmN0aW9uIGZvciBidWlsZGluZyB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgKiBJZiBhbiBvdmVybGFwIGlzIGZvdW5kLCBmaW5kIHRoZSBvdmVybGFwcyBmb3IgdGhhdCBvdmVybGFwXG4gICAgICogQHBhcmFtIHRodW1iSW5kZXggY3VycmVudCBUaHVtYiBpbmRleCB0byBmaW5kIG92ZXJsYXBzIGZyb21cbiAgICAgKi9cbiAgICB2YXIgYnVpbGRPdmVybGFwcyA9IGZ1bmN0aW9uICh0aHVtYkluZGV4KSB7XG4gICAgICAgIHZhciB0aHVtYlhXaWR0aCA9IGdldFRodW1iV2lkdGgodGh1bWJzW3RodW1iSW5kZXhdLCB2YWx1ZXNbdGh1bWJJbmRleF0sIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgdmFyIHRodW1iWCA9IG9mZnNldHNbdGh1bWJJbmRleF0ueDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgVGh1bWIgb2Zmc2V0cywgaWYgdGhlcmUgaXMgYSBtYXRjaFxuICAgICAgICAgKiBhZGQgdGhlIHRodW1iSW5kZXggYW5kIHNpYmxpbmdJbmRleCB0byB0aGUgb3ZlcmxhcHMgQXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlbiBidWlsZCBvdmVybGFwcyBmcm9tIHRoZSBvdmVybGFwcGluZyBzaWJsaW5nSW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoX2EsIHNpYmxpbmdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdYID0gX2EueDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nV2lkdGggPSBnZXRUaHVtYldpZHRoKHRodW1ic1tzaWJsaW5nSW5kZXhdLCB2YWx1ZXNbc2libGluZ0luZGV4XSwgc2VwYXJhdG9yLCBkZWNpbWFsUGxhY2VzLCB2YWx1ZVRvTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHRodW1iSW5kZXggIT09IHNpYmxpbmdJbmRleCAmJlxuICAgICAgICAgICAgICAgICgodGh1bWJYID49IHNpYmxpbmdYICYmIHRodW1iWCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRodW1iWCArIHRodW1iWFdpZHRoID49IHNpYmxpbmdYICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHVtYlggKyB0aHVtYlhXaWR0aCA8PSBzaWJsaW5nWCArIHNpYmxpbmdXaWR0aCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvdmVybGFwcy5pbmNsdWRlcyhzaWJsaW5nSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2godGh1bWJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLnB1c2goc2libGluZ0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHMgPSBfX3NwcmVhZEFycmF5cyhvdmVybGFwcywgW3RodW1iSW5kZXgsIHNpYmxpbmdJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBidWlsZE92ZXJsYXBzKHNpYmxpbmdJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGJ1aWxkT3ZlcmxhcHMoaW5kZXgpO1xuICAgIC8vIFNvcnQgYW5kIHJlbW92ZSBkdXBsaWNhdGVzIGZyb20gdGhlIGJ1aWx0IG92ZXJsYXBzXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChvdmVybGFwcy5zb3J0KCkpKTtcbn07XG4vKipcbiAqIEEgY3VzdG9tIFJlYWN0IEhvb2sgZm9yIGNhbGN1bGF0aW5nIHdoZXRoZXIgYSB0aHVtYiBvdmVybGFwc1xuICogYW5vdGhlciBhbmQgd2hldGhlciBsYWJlbHMgY291bGQvc2hvdWxkIG1lcmdlLlxuICogQHBhcmFtIHJhbmdlUmVmIC0gUmVhY3QgcmVmIHZhbHVlIG9mIFJhbmdlIGNvbXBvbmVudFxuICogQHBhcmFtIHZhbHVlcyAtIGN1cnJlbnQgUmFuZ2UgdmFsdWVzIEFycmF5XG4gKiBAcGFyYW0gaW5kZXggLSB0aHVtYiBpbmRleFxuICogQHBhcmFtIHN0ZXAgLSBzdGVwIHZhbHVlLCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBAcGFyYW0gc2VwYXJhdG9yIC0gc3RyaW5nIHRvIHNlcGFyYXRlIHRodW1iIHZhbHVlc1xuICogQHJldHVybnMgbGFiZWwgdmFsdWUgKyBzdHlsaW5nIGZvciB0aHVtYiBsYWJlbFxuICovXG52YXIgdXNlVGh1bWJPdmVybGFwID0gZnVuY3Rpb24gKHJhbmdlUmVmLCB2YWx1ZXMsIGluZGV4LCBzdGVwLCBzZXBhcmF0b3IsIHZhbHVlVG9MYWJlbCkge1xuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDAuMTsgfVxuICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBzZXBhcmF0b3IgPSAnIC0gJzsgfVxuICAgIGlmICh2YWx1ZVRvTGFiZWwgPT09IHZvaWQgMCkgeyB2YWx1ZVRvTGFiZWwgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9OyB9XG4gICAgdmFyIGRlY2ltYWxQbGFjZXMgPSBleHBvcnRzLmdldFN0ZXBEZWNpbWFscyhzdGVwKTtcbiAgICAvLyBDcmVhdGUgaW5pdGlhbCBsYWJlbCBzdHlsZSBhbmQgdmFsdWUuIExhYmVsIHZhbHVlIGRlZmF1bHRzIHRvIHRodW1iIHZhbHVlXG4gICAgdmFyIF9hID0gcmVhY3RfMS51c2VTdGF0ZSh7fSksIGxhYmVsU3R5bGUgPSBfYVswXSwgc2V0TGFiZWxTdHlsZSA9IF9hWzFdO1xuICAgIHZhciBfYiA9IHJlYWN0XzEudXNlU3RhdGUodmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSkpLCBsYWJlbFZhbHVlID0gX2JbMF0sIHNldExhYmVsVmFsdWUgPSBfYlsxXTtcbiAgICAvLyBXaGVuIHRoZSByYW5nZVJlZiBvciB2YWx1ZXMgY2hhbmdlLCB1cGRhdGUgdGhlIFRodW1iIGxhYmVsIHZhbHVlcyBhbmQgc3R5bGluZ1xuICAgIHJlYWN0XzEudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgICAgICB2YXIgdGh1bWJzID0gcmFuZ2VSZWYuZ2V0VGh1bWJzKCk7XG4gICAgICAgICAgICBpZiAodGh1bWJzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1N0eWxlID0ge307XG4gICAgICAgICAgICB2YXIgb2Zmc2V0c18xID0gcmFuZ2VSZWYuZ2V0T2Zmc2V0cygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYW55IG92ZXJsYXBzIGZvciB0aGUgZ2l2ZW4gVGh1bWIgaW5kZXguIFRoaXMgbXVzdCByZXR1cm4gYWxsIGxpbmtlZFxuICAgICAgICAgICAgICogVGh1bWJzLiBTbyBpZiB0aGVyZSBhcmUgNCBUaHVtYnMgYW5kIFRodW1icyAyLCAzIGFuZCA0IG92ZXJsYXAuIElmIHdlIGFyZVxuICAgICAgICAgICAgICogZ2V0dGluZyB0aGUgb3ZlcmxhcHMgZm9yIFRodW1iIDEgYW5kIGl0IG92ZXJsYXBzIG9ubHkgVGh1bWIgMiwgd2UgbXVzdCBnZXRcbiAgICAgICAgICAgICAqIDIsIDMgYW5kIDQgYWxzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG92ZXJsYXBzID0gZ2V0T3ZlcmxhcHMoaW5kZXgsIG9mZnNldHNfMSwgdGh1bWJzLCB2YWx1ZXMsIHNlcGFyYXRvciwgZGVjaW1hbFBsYWNlcywgdmFsdWVUb0xhYmVsKTtcbiAgICAgICAgICAgIC8vIFNldCBhIGRlZmF1bHQgbGFiZWwgdmFsdWUgb2YgdGhlIFRodW1iIHZhbHVlXG4gICAgICAgICAgICB2YXIgbGFiZWxWYWx1ZV8xID0gdmFsdWVUb0xhYmVsKHZhbHVlc1tpbmRleF0udG9GaXhlZChkZWNpbWFsUGxhY2VzKSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlIGFyZSBvdmVybGFwcyBmb3IgdGhlIFRodW1iLCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICogTGFiZWwgdmFsdWUgYWxvbmcgd2l0aCB0aGUgcmVsZXZhbnQgc3R5bGluZy4gV2Ugb25seSB3YW50IHRvIHNob3cgYSBMYWJlbFxuICAgICAgICAgICAgICogZm9yIHRoZSBsZWZ0IG1vc3QgVGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0LlxuICAgICAgICAgICAgICogQWxsIG90aGVyIFRodW1icyB3aWxsIGJlIHNldCB0byBkaXNwbGF5OiBub25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAob3ZlcmxhcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogR2V0IGFuIEFycmF5IG9mIHRoZSBvZmZzZXRzIGZvciB0aGUgb3ZlcmxhcHBpbmcgVGh1bWJzXG4gICAgICAgICAgICAgICAgICogVGhpcyBpcyBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGlmIHRoZSBUaHVtYiB3ZSBhcmUgbG9va2luZyBhdFxuICAgICAgICAgICAgICAgICAqIGlzIHRoZSBsZWZ0IG1vc3QgdGh1bWIgaW4gYW4gb3ZlcmxhcHBpbmcgc2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldHNYID0gb3ZlcmxhcHMucmVkdWNlKGZ1bmN0aW9uIChhLCBjLCBpLCBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA/IF9fc3ByZWFkQXJyYXlzKGEsIFtvZmZzZXRzXzFbc1tpXV0ueF0pIDogW29mZnNldHNfMVtzW2ldXS54XTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgb3VyIFRodW1iIGlzIHRoZSBsZWZ0IG1vc3QgVGh1bWIsIHdlIGNhbiBidWlsZCBhIExhYmVsIHZhbHVlXG4gICAgICAgICAgICAgICAgICogYW5kIHNldCB0aGUgc3R5bGUgZm9yIHRoYXQgTGFiZWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4uYXBwbHkoTWF0aCwgb2Zmc2V0c1gpID09PSBvZmZzZXRzXzFbaW5kZXhdLngpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEZpcnN0IGNhbGN1bGF0ZSB0aGUgTGFiZWwgdmFsdWUuIFRvIGRvIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAqIGdyYWIgYWxsIHRoZSB2YWx1ZXMgZm9yIHRoZSBUaHVtYnMgaW4gb3VyIG92ZXJsYXBzLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGVuIGNvbnZlcnQgdGhhdCB0byBhIFNldCBhbmQgc29ydCBpdCB3aGlsc3QgcmVtb3ZpbmcgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFZhbHVlc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBzLmZvckVhY2goZnVuY3Rpb24gKHRodW1iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFZhbHVlc18xLnB1c2godmFsdWVzW3RodW1iXS50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiAgVXBkYXRlIHRoZSBsYWJlbFZhbHVlIHdpdGggdGhlIHJlc3VsdGluZyBBcnJheVxuICAgICAgICAgICAgICAgICAgICAgKiAgam9pbmVkIGJ5IG91ciBkZWZpbmVkIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxWYWx1ZV8xID0gQXJyYXkuZnJvbShuZXcgU2V0KGxhYmVsVmFsdWVzXzEuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gcGFyc2VGbG9hdChhKSAtIHBhcnNlRmxvYXQoYik7IH0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAodmFsdWVUb0xhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIExhc3RseSwgYnVpbGQgdGhlIGxhYmVsIHN0eWxpbmcuIFRoZSBsYWJlbCBzdHlsaW5nIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICogcG9zaXRpb24gdGhlIGxhYmVsIGFuZCBhcHBseSBhIHRyYW5zZm9ybSBzbyB0aGF0IGl0J3MgY2VudGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHdhbnQgdGhlIGNlbnRlciBwb2ludCBiZXR3ZWVuIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGxlZnQgbW9zdCBUaHVtYlxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHJpZ2h0IG1vc3QgVGh1bWIuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBNYXRoLm1pbi5hcHBseShNYXRoLCBvZmZzZXRzWCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgb2Zmc2V0c1gpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gdGh1bWJzW292ZXJsYXBzW29mZnNldHNYLmluZGV4T2YobGFzdCldXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGUubGVmdCA9IE1hdGguYWJzKGZpcnN0IC0gKGxhc3QgKyBsYXN0V2lkdGgpKSAvIDIgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwgMCknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIFRodW1iIGlzbid0IHRoZSBsZWZ0IG1vc3QgVGh1bWIsIGhpZGUgdGhlIExhYmVsIVxuICAgICAgICAgICAgICAgICAgICBuZXdTdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYWJlbCB2YWx1ZSBhbmQgc3R5bGVcbiAgICAgICAgICAgIHNldExhYmVsVmFsdWUobGFiZWxWYWx1ZV8xKTtcbiAgICAgICAgICAgIHNldExhYmVsU3R5bGUobmV3U3R5bGUpO1xuICAgICAgICB9XG4gICAgfSwgW3JhbmdlUmVmLCB2YWx1ZXNdKTtcbiAgICByZXR1cm4gW2xhYmVsVmFsdWUsIGxhYmVsU3R5bGVdO1xufTtcbmV4cG9ydHMudXNlVGh1bWJPdmVybGFwID0gdXNlVGh1bWJPdmVybGFwO1xuLyoqXG4gKiBVdGlsIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyB0aGUgZGlzdGFuY2Ugb2YgdGhlIGNlbnRlciBvZiBhIHRodW1iXG4gKiBmb3JtIGEgZ2l2ZW4gbW91c2UvdG91Y2ggdGFyZ2V0J3MgcG9zaXRpb25cbiAqIEBwYXJhbSB0aHVtYkVsIC0gVGh1bWIgZWxlbWVudCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGZyb21cbiAqIEBwYXJhbSBjbGllbnRYIC0gdGFyZ2V0IHggcG9zaXRpb24gKG1vdXNlL3RvdWNoKVxuICogQHBhcmFtIGNsaWVudFkgLSB0YXJnZXQgeSBwb3NpdGlvbiAobW91c2UvdG91Y2gpXG4gKiBAcGFyYW0gZGlyZWN0aW9uIC0gdGhlIGRpcmVjdGlvbiBvZiB0aGUgdHJhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0VGh1bWJEaXN0YW5jZSh0aHVtYkVsLCBjbGllbnRYLCBjbGllbnRZLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgX2EgPSB0aHVtYkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgcmV0dXJuIGlzVmVydGljYWwoZGlyZWN0aW9uKSA/IE1hdGguYWJzKGNsaWVudFkgLSAodG9wICsgaGVpZ2h0IC8gMikpIDogTWF0aC5hYnMoY2xpZW50WCAtIChsZWZ0ICsgd2lkdGggLyAyKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/baseui/node_modules/react-range/lib/utils.js\n");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/layout */ \"./components/layout.js\");\n/* harmony import */ var baseui_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! baseui/card */ \"./node_modules/baseui/esm/card/index.js\");\n/* harmony import */ var baseui_button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! baseui/button */ \"./node_modules/baseui/esm/button/index.js\");\n/* harmony import */ var baseui_input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! baseui/input */ \"./node_modules/baseui/esm/input/index.js\");\n/* harmony import */ var baseui_accordion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! baseui/accordion */ \"./node_modules/baseui/esm/accordion/index.js\");\n/* harmony import */ var baseui_slider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! baseui/slider */ \"./node_modules/baseui/esm/slider/index.js\");\n\n\n\n\n\n\n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_layout__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_card__WEBPACK_IMPORTED_MODULE_2__.Card, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_card__WEBPACK_IMPORTED_MODULE_2__.StyledBody, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_input__WEBPACK_IMPORTED_MODULE_3__.Input, {\n                            clearOnEscape: true\n                        }, void 0, false, {\n                            fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                            lineNumber: 14,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_button__WEBPACK_IMPORTED_MODULE_4__.Button, {\n                            children: \"Copy\"\n                        }, void 0, false, {\n                            fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                            lineNumber: 15,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                    lineNumber: 13,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_card__WEBPACK_IMPORTED_MODULE_2__.StyledAction, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_accordion__WEBPACK_IMPORTED_MODULE_5__.Accordion, {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_accordion__WEBPACK_IMPORTED_MODULE_5__.Panel, {\n                            title: \"Options\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(baseui_slider__WEBPACK_IMPORTED_MODULE_6__.Slider, {}, void 0, false, {\n                                fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                                lineNumber: 20,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                            lineNumber: 19,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                        lineNumber: 18,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n                    lineNumber: 17,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n            lineNumber: 12,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/mlokhate/Documents/password-generator-baseweb/pages/index.js\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUEwQztBQUNHO0FBQ2dCO0FBQ3RCO0FBQ0Y7QUFDZTtBQUNiO0FBRXZDLFNBQVNVLElBQUksR0FBRztJQUNkLHFCQUNFLDhEQUFDViwwREFBTTtrQkFDTCw0RUFBQ0UsNkNBQUk7OzhCQUNILDhEQUFDRSxtREFBVTs7c0NBQ1QsOERBQUNFLCtDQUFLOzRCQUFDSyxhQUFhOzs7OztnQ0FBRztzQ0FDdkIsOERBQUNOLGlEQUFNO3NDQUFDLE1BQUk7Ozs7O2dDQUFTOzs7Ozs7d0JBQ1Y7OEJBQ2IsOERBQUNGLHFEQUFZOzhCQUNYLDRFQUFDSSx1REFBUztrQ0FDUiw0RUFBQ0MsbURBQUs7NEJBQUNJLEtBQUssRUFBQyxTQUFTO3NDQUNwQiw0RUFBQ0gsaURBQU07Ozs7b0NBQUc7Ozs7O2dDQUNKOzs7Ozs0QkFDRTs7Ozs7d0JBQ0M7Ozs7OztnQkFDVjs7Ozs7WUFDQSxDQUNUO0NBQ0g7QUFsQlFDLEtBQUFBLElBQUk7QUFvQmIsK0RBQWVBLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9pbmRleC5qcz9iZWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMYXlvdXQgZnJvbSBcIi4uL2NvbXBvbmVudHMvbGF5b3V0XCI7XG5pbXBvcnQgeyBTdGF0ZWZ1bElucHV0IH0gZnJvbSBcImJhc2V1aS9pbnB1dFwiO1xuaW1wb3J0IHsgQ2FyZCwgU3R5bGVkQWN0aW9uLCBTdHlsZWRCb2R5IH0gZnJvbSBcImJhc2V1aS9jYXJkXCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiYmFzZXVpL2J1dHRvblwiO1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tIFwiYmFzZXVpL2lucHV0XCI7XG5pbXBvcnQgeyBBY2NvcmRpb24sIFBhbmVsIH0gZnJvbSBcImJhc2V1aS9hY2NvcmRpb25cIjtcbmltcG9ydCB7IFNsaWRlciB9IGZyb20gXCJiYXNldWkvc2xpZGVyXCI7XG5cbmZ1bmN0aW9uIEhvbWUoKSB7XG4gIHJldHVybiAoXG4gICAgPExheW91dD5cbiAgICAgIDxDYXJkPlxuICAgICAgICA8U3R5bGVkQm9keT5cbiAgICAgICAgICA8SW5wdXQgY2xlYXJPbkVzY2FwZSAvPlxuICAgICAgICAgIDxCdXR0b24+Q29weTwvQnV0dG9uPlxuICAgICAgICA8L1N0eWxlZEJvZHk+XG4gICAgICAgIDxTdHlsZWRBY3Rpb24+XG4gICAgICAgICAgPEFjY29yZGlvbj5cbiAgICAgICAgICAgIDxQYW5lbCB0aXRsZT1cIk9wdGlvbnNcIj5cbiAgICAgICAgICAgICAgPFNsaWRlciAvPlxuICAgICAgICAgICAgPC9QYW5lbD5cbiAgICAgICAgICA8L0FjY29yZGlvbj5cbiAgICAgICAgPC9TdHlsZWRBY3Rpb24+XG4gICAgICA8L0NhcmQ+XG4gICAgPC9MYXlvdXQ+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWU7XG4iXSwibmFtZXMiOlsiTGF5b3V0IiwiU3RhdGVmdWxJbnB1dCIsIkNhcmQiLCJTdHlsZWRBY3Rpb24iLCJTdHlsZWRCb2R5IiwiQnV0dG9uIiwiSW5wdXQiLCJBY2NvcmRpb24iLCJQYW5lbCIsIlNsaWRlciIsIkhvbWUiLCJjbGVhck9uRXNjYXBlIiwidGl0bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n");

/***/ })

});